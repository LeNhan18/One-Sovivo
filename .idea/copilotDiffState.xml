<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app.py" />
              <option name="originalContent" value="# app.py&#10;# -*- coding: utf-8 -*-&#10;&#10;from flask import Flask, jsonify, request, send_from_directory&#10;from flask_cors import CORS&#10;from flask_sqlalchemy import SQLAlchemy&#10;from flask_bcrypt import Bcrypt&#10;import jwt&#10;import datetime&#10;import time&#10;import uuid&#10;import random&#10;from functools import wraps&#10;import pandas as pd&#10;import numpy as np&#10;import tensorflow as tf&#10;from sklearn.preprocessing import StandardScaler, OneHotEncoder&#10;import joblib&#10;import os&#10;import matplotlib&#10;from config import Config&#10;&#10;matplotlib.use('Agg')  # Backend không GUI cho matplotlib&#10;import matplotlib.pyplot as plt&#10;&#10;# Import blockchain integration for NFT achievements&#10;try:&#10;    from blockchain_simple import update_nft_on_blockchain, get_nft_metadata&#10;    from blockchain_config import (&#10;        evaluate_all_achievements,&#10;        get_highest_rank_from_achievements,&#10;        ACHIEVEMENT_CONFIG&#10;    )&#10;&#10;    BLOCKCHAIN_ENABLED = True&#10;    print(&quot;Blockchain integration loaded successfully&quot;)&#10;except ImportError as e:&#10;    print(f&quot;Blockchain integration not available: {e}&quot;)&#10;    BLOCKCHAIN_ENABLED = False&#10;&#10;# Import mission progression system&#10;try:&#10;    from mission_progression import mission_system, get_missions_for_customer&#10;    from detailed_missions import DetailedMissionSystem&#10;&#10;    MISSION_SYSTEM_ENABLED = True&#10;    print(&quot;Mission progression system loaded successfully&quot;)&#10;except ImportError as e:&#10;    print(f&quot;Mission progression system not available: {e}&quot;)&#10;    MISSION_SYSTEM_ENABLED = False&#10;&#10;# =============================================================================&#10;# KHỞI TẠO VÀ CẤU HÌNH&#10;# =============================================================================&#10;app = Flask(__name__)&#10;app.config.from_object(Config)&#10;&#10;# Initialize detailed mission system&#10;detailed_mission_system = DetailedMissionSystem()&#10;&#10;db = SQLAlchemy(app)&#10;bcrypt = Bcrypt(app)&#10;cors = CORS(app)&#10;&#10;# Biến toàn cục cho AI model&#10;ai_model = None&#10;scaler = None&#10;encoder = None&#10;feature_columns = ['age', 'avg_balance', 'total_flights', 'is_business_flyer_int', 'total_nights_stayed',&#10;                   'total_resort_spending']&#10;&#10;&#10;# =============================================================================&#10;# DATABASE MODELS&#10;# =============================================================================&#10;class User(db.Model):&#10;    __tablename__ = 'users'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    email = db.Column(db.String(120), unique=True, nullable=False)&#10;    name = db.Column(db.String(100), nullable=False)&#10;    password_hash = db.Column(db.String(255), nullable=False)&#10;    role = db.Column(db.Enum('admin', 'customer'), default='customer')&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.id'), nullable=True)&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;    updated_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)&#10;&#10;    # Relationship to get actual customer record&#10;    customer = db.relationship('Customer', backref='user_accounts')&#10;&#10;    def set_password(self, password):&#10;        self.password_hash = bcrypt.generate_password_hash(password).decode('utf-8')&#10;&#10;    def check_password(self, password):&#10;        return bcrypt.check_password_hash(self.password_hash, password)&#10;&#10;&#10;class Customer(db.Model):&#10;    __tablename__ = 'customers'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    customer_id = db.Column(db.Integer, unique=True, nullable=False)&#10;    name = db.Column(db.String(100), nullable=False)&#10;    age = db.Column(db.Integer)&#10;    gender = db.Column(db.Enum('Nam', 'Nữ', 'Khác'))&#10;    job = db.Column(db.String(100))&#10;    city = db.Column(db.String(100))&#10;    persona_type = db.Column(db.Enum('doanh_nhan', 'gia_dinh', 'nguoi_tre'))&#10;    nft_token_id = db.Column(db.Integer, nullable=True)  # ID của NFT Passport trên blockchain&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;    updated_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)&#10;&#10;&#10;class HDBankTransaction(db.Model):&#10;    __tablename__ = 'hdbank_transactions'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    transaction_id = db.Column(db.String(50), unique=True, nullable=False)&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False)&#10;    transaction_date = db.Column(db.DateTime, nullable=False)&#10;    amount = db.Column(db.Numeric(15, 2), nullable=False)&#10;    # Expanded enum to align with usage across endpoints&#10;    transaction_type = db.Column(db.Enum('credit', 'debit', 'transfer', 'loan_disbursement'), nullable=False)&#10;    # Balance can be null when not tracked on some operations&#10;    balance = db.Column(db.Numeric(15, 2), nullable=True)&#10;    description = db.Column(db.Text)&#10;    status = db.Column(db.String(30), default='completed')&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;&#10;&#10;class HDBankCard(db.Model):&#10;    __tablename__ = 'hdbank_cards'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False, index=True)&#10;    card_id = db.Column(db.String(50), unique=True, nullable=False)&#10;    card_number = db.Column(db.String(20), nullable=False)&#10;    card_type = db.Column(db.Enum('classic', 'gold', 'platinum'), nullable=False)&#10;    card_name = db.Column(db.String(100), nullable=False)&#10;    credit_limit = db.Column(db.BigInteger, nullable=False)&#10;    annual_fee = db.Column(db.BigInteger, nullable=False)&#10;    status = db.Column(db.Enum('active', 'blocked', 'expired'), default='active')&#10;    opened_date = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;    expiry_date = db.Column(db.DateTime, nullable=False)&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;    updated_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)&#10;&#10;    def to_dict(self):&#10;        return {&#10;            'card_id': self.card_id,&#10;            'card_number': f&quot;****-****-****-{self.card_number[-4:]}&quot;,&#10;            'card_type': self.card_type,&#10;            'card_name': self.card_name,&#10;            'credit_limit': self.credit_limit,&#10;            'status': self.status,&#10;            'opened_date': self.opened_date.strftime('%Y-%m-%d'),&#10;            'expiry_date': self.expiry_date.strftime('%Y-%m-%d')&#10;        }&#10;&#10;&#10;class VietjetFlight(db.Model):&#10;    __tablename__ = 'vietjet_flights'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    flight_id = db.Column(db.String(50), unique=True, nullable=False)&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False)&#10;    flight_date = db.Column(db.DateTime, nullable=False)&#10;    origin = db.Column(db.String(10), nullable=False)&#10;    destination = db.Column(db.String(10), nullable=False)&#10;    ticket_class = db.Column(db.Enum('economy', 'business'), nullable=False)&#10;    booking_value = db.Column(db.Numeric(12, 2), nullable=False)&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;&#10;&#10;class ResortBooking(db.Model):&#10;    __tablename__ = 'resort_bookings'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    booking_id = db.Column(db.String(50), unique=True, nullable=False)&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False)&#10;    resort_name = db.Column(db.String(200), nullable=False)&#10;    booking_date = db.Column(db.DateTime, nullable=False)&#10;    nights_stayed = db.Column(db.Integer, nullable=False)&#10;    booking_value = db.Column(db.Numeric(12, 2), nullable=False)&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;&#10;&#10;class TokenTransaction(db.Model):&#10;    __tablename__ = 'token_transactions'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    tx_hash = db.Column(db.String(100), unique=True, nullable=False)&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False)&#10;    transaction_type = db.Column(db.String(50), nullable=False)&#10;    amount = db.Column(db.Numeric(10, 2), nullable=False)&#10;    description = db.Column(db.Text)&#10;    block_number = db.Column(db.Integer)&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;&#10;&#10;# =============================================================================&#10;# ACHIEVEMENTS &amp; NFT PASSPORT MODELS&#10;# =============================================================================&#10;class Achievement(db.Model):&#10;    __tablename__ = 'achievements'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    name = db.Column(db.String(100), nullable=False)  # ví dụ: &quot;Phi công Vàng&quot;&#10;    description = db.Column(db.Text, nullable=False)  # &quot;Bay hơn 20 chuyến trong năm&quot;&#10;    badge_image_url = db.Column(db.String(200))  # Đường dẫn đến hình ảnh huy hiệu&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;&#10;&#10;class CustomerAchievement(db.Model):&#10;    __tablename__ = 'customer_achievements'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False)&#10;    achievement_id = db.Column(db.Integer, db.ForeignKey('achievements.id'), nullable=False)&#10;    unlocked_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;&#10;    # Relationships&#10;    customer = db.relationship('Customer', backref='achievements')&#10;    achievement = db.relationship('Achievement', backref='customers')&#10;&#10;&#10;class CustomerMission(db.Model):&#10;    __tablename__ = 'customer_missions'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False)&#10;    mission_id = db.Column(db.String(100), nullable=False)  # ID từ mission progression system&#10;    mission_title = db.Column(db.String(200), nullable=False)&#10;    mission_category = db.Column(db.String(50), nullable=False)&#10;    mission_level = db.Column(db.String(50), nullable=False)&#10;    status = db.Column(db.Enum('available', 'in_progress', 'completed', 'expired'), default='available')&#10;    progress_data = db.Column(db.JSON)  # Lưu trữ tiến trình chi tiết&#10;    svt_reward = db.Column(db.Numeric(10, 2), default=0)&#10;    started_at = db.Column(db.DateTime, nullable=True)&#10;    completed_at = db.Column(db.DateTime, nullable=True)&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;&#10;    # Relationships&#10;    customer = db.relationship('Customer', backref='missions')&#10;&#10;&#10;class CustomerMissionProgress(db.Model):&#10;    __tablename__ = 'customer_mission_progress'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False)&#10;    mission_id = db.Column(db.String(100), nullable=False)&#10;    requirement_key = db.Column(db.String(100), nullable=False)  # Ví dụ: login_count, transaction_count&#10;    current_value = db.Column(db.Numeric(15, 2), default=0)&#10;    required_value = db.Column(db.Numeric(15, 2), nullable=False)&#10;    is_completed = db.Column(db.Boolean, default=False)&#10;    updated_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)&#10;&#10;    # Relationships&#10;    customer = db.relationship('Customer', backref='mission_progress')&#10;&#10;&#10;# =============================================================================&#10;# MARKETPLACE &amp; P2P MODELS&#10;# =============================================================================&#10;class MarketplaceItem(db.Model):&#10;    __tablename__ = 'marketplace_items'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    name = db.Column(db.String(100), nullable=False)  # &quot;Voucher ăn uống 100K&quot;&#10;    description = db.Column(db.Text)&#10;    price_svt = db.Column(db.Numeric(10, 2), nullable=False)  # Giá bán bằng SVT&#10;    quantity = db.Column(db.Integer, default=0)  # Số lượng còn lại&#10;    partner_brand = db.Column(db.String(50))  # HDBank, Vietjet, Sovico...&#10;    image_url = db.Column(db.String(200))  # Hình ảnh sản phẩm&#10;    is_active = db.Column(db.Boolean, default=True)&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;&#10;&#10;class P2PListing(db.Model):&#10;    __tablename__ = 'p2p_listings'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    seller_customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False)&#10;    item_name = db.Column(db.String(100), nullable=False)&#10;    description = db.Column(db.Text)&#10;    price_svt = db.Column(db.Numeric(10, 2), nullable=False)&#10;    status = db.Column(db.Enum('active', 'sold', 'cancelled'), default='active')&#10;    buyer_customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=True)&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;    sold_at = db.Column(db.DateTime, nullable=True)&#10;&#10;    # Relationships&#10;    seller = db.relationship('Customer', foreign_keys=[seller_customer_id], backref='p2p_listings')&#10;    buyer = db.relationship('Customer', foreign_keys=[buyer_customer_id], backref='p2p_purchases')&#10;&#10;&#10;# =============================================================================&#10;# AUTH UTILITIES&#10;# =============================================================================&#10;def create_token(user_id: int):&#10;    payload = {&#10;        'sub': user_id,&#10;        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=8)&#10;    }&#10;    return jwt.encode(payload, app.config['SECRET_KEY'], algorithm='HS256')&#10;&#10;&#10;def verify_token(token: str):&#10;    try:&#10;        data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])&#10;        return data.get('sub')&#10;    except Exception:&#10;        return None&#10;&#10;&#10;def require_auth(func):&#10;    @wraps(func)&#10;    def wrapper(*args, **kwargs):&#10;        auth_header = request.headers.get('Authorization', '')&#10;        if not auth_header.startswith('Bearer '):&#10;            return jsonify({'error': 'Unauthorized'}), 401&#10;        token = auth_header.split(' ', 1)[1]&#10;        user_id = verify_token(token)&#10;        if not user_id:&#10;            return jsonify({'error': 'Unauthorized'}), 401&#10;        user = User.query.get(user_id)&#10;        if not user:&#10;            return jsonify({'error': 'Unauthorized'}), 401&#10;        request.current_user = user&#10;        return func(*args, **kwargs)&#10;&#10;    return wrapper&#10;&#10;&#10;# =============================================================================&#10;# AI MODEL UTILITIES&#10;# =============================================================================&#10;def plot_and_save_metrics(history, model_dir):&#10;    &quot;&quot;&quot;Vẽ và lưu biểu đồ accuracy và loss.&quot;&quot;&quot;&#10;    plt.figure(figsize=(12, 5))&#10;    # Biểu đồ Accuracy&#10;    plt.subplot(1, 2, 1)&#10;    plt.plot(history.history['accuracy'], label='Training Accuracy')&#10;    plt.title('Model Accuracy')&#10;    plt.ylabel('Accuracy')&#10;    plt.xlabel('Epoch')&#10;    plt.legend(loc='lower right')&#10;    # Biểu đồ Loss&#10;    plt.subplot(1, 2, 2)&#10;    plt.plot(history.history['loss'], label='Training Loss')&#10;    plt.title('Model Loss')&#10;    plt.ylabel('Loss')&#10;    plt.xlabel('Epoch')&#10;    plt.legend(loc='upper right')&#10;&#10;    plt.tight_layout()&#10;    metrics_path = os.path.join(model_dir, 'training_metrics.png')&#10;    plt.savefig(metrics_path)&#10;    plt.close()&#10;    print(f&quot;Đã lưu biểu đồ Metrics tại: {metrics_path}&quot;)&#10;&#10;&#10;def train_and_save_model():&#10;    &quot;&quot;&quot;Huấn luyện và lưu model Deep Learning từ MySQL data.&quot;&quot;&quot;&#10;    global ai_model, scaler, encoder&#10;    print(&quot;Bắt đầu huấn luyện Model AI từ dữ liệu MySQL...&quot;)&#10;&#10;    # Lấy dữ liệu từ MySQL&#10;    customers_query = &quot;&quot;&quot;&#10;        SELECT c.customer_id, c.name, c.age, c.persona_type,&#10;               COALESCE(AVG(h.balance), 0) as avg_balance,&#10;               COALESCE(COUNT(DISTINCT v.flight_id), 0) as total_flights,&#10;               COALESCE(MAX(CASE WHEN v.ticket_class = 'business' THEN 1 ELSE 0 END), 0) as is_business_flyer,&#10;               COALESCE(SUM(r.nights_stayed), 0) as total_nights_stayed,&#10;               COALESCE(SUM(r.booking_value), 0) as total_resort_spending&#10;        FROM customers c&#10;        LEFT JOIN hdbank_transactions h ON c.customer_id = h.customer_id&#10;        LEFT JOIN vietjet_flights v ON c.customer_id = v.customer_id&#10;        LEFT JOIN resort_bookings r ON c.customer_id = r.customer_id&#10;        WHERE c.persona_type IS NOT NULL&#10;        GROUP BY c.customer_id, c.name, c.age, c.persona_type&#10;    &quot;&quot;&quot;&#10;&#10;    merged_df = pd.read_sql(customers_query, db.engine)&#10;&#10;    if merged_df.empty:&#10;        print(&quot;Không có dữ liệu để huấn luyện. Tạo dữ liệu mẫu...&quot;)&#10;        return create_mock_model()&#10;&#10;    # Feature Engineering&#10;    merged_df['is_business_flyer_int'] = merged_df['is_business_flyer'].astype(int)&#10;    merged_df.fillna(0, inplace=True)&#10;&#10;    X_raw = merged_df[feature_columns]&#10;    y_raw = merged_df[['persona_type']]&#10;&#10;    # Chuẩn hóa và mã hóa&#10;    scaler = StandardScaler()&#10;    X_scaled = scaler.fit_transform(X_raw)&#10;&#10;    encoder = OneHotEncoder(sparse_output=False)&#10;    y_encoded = encoder.fit_transform(y_raw)&#10;&#10;    # Xây dựng và huấn luyện model&#10;    model = tf.keras.Sequential([&#10;        tf.keras.layers.Input(shape=(X_scaled.shape[1],)),&#10;        tf.keras.layers.Dense(64, activation='relu'),&#10;        tf.keras.layers.Dense(32, activation='relu'),&#10;        tf.keras.layers.Dense(y_encoded.shape[1], activation='softmax')&#10;    ])&#10;    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])&#10;    history = model.fit(X_scaled, y_encoded, epochs=15, batch_size=64, verbose=1)&#10;&#10;    # Lưu trữ&#10;    if not os.path.exists(app.config['MODEL_DIR']):&#10;        os.makedirs(app.config['MODEL_DIR'])&#10;&#10;    model.save(os.path.join(app.config['MODEL_DIR'], 'persona_model.h5'))&#10;    joblib.dump(scaler, os.path.join(app.config['MODEL_DIR'], 'scaler.pkl'))&#10;    joblib.dump(encoder, os.path.join(app.config['MODEL_DIR'], 'encoder.pkl'))&#10;&#10;    plot_and_save_metrics(history, app.config['MODEL_DIR'])&#10;&#10;    ai_model, scaler, encoder = model, scaler, encoder&#10;    print(f&quot;Huấn luyện Model thành công!&quot;)&#10;&#10;&#10;def create_mock_model():&#10;    &quot;&quot;&quot;Tạo model mẫu nếu chưa có dữ liệu&quot;&quot;&quot;&#10;    global ai_model, scaler, encoder&#10;    print(&quot;Tạo Mock Model để demo...&quot;)&#10;&#10;    # Mock scaler và encoder&#10;    scaler = StandardScaler()&#10;    scaler.mean_ = np.array([35, 100000000, 10, 0.5, 3, 10000000])&#10;    scaler.scale_ = np.array([10, 50000000, 8, 0.5, 2, 5000000])&#10;&#10;    encoder = OneHotEncoder(sparse_output=False)&#10;    encoder.categories_ = [np.array(['doanh_nhan', 'gia_dinh', 'nguoi_tre'])]&#10;&#10;    # Mock model (sử dụng logic đơn giản)&#10;    class MockModel:&#10;        def predict(self, X):&#10;            # Logic đơn giản dựa trên features&#10;            results = []&#10;            for row in X:&#10;                age, balance, flights, is_biz, nights, resort_spending = row&#10;                if balance &gt; 200000000 or is_biz &gt; 0.5:&#10;                    results.append([0.8, 0.15, 0.05])  # doanh_nhan&#10;                elif age &lt; 30:&#10;                    results.append([0.1, 0.2, 0.7])  # nguoi_tre&#10;                else:&#10;                    results.append([0.2, 0.7, 0.1])  # gia_dinh&#10;            return np.array(results)&#10;&#10;    ai_model = MockModel()&#10;&#10;    # Lưu mock files&#10;    if not os.path.exists(app.config['MODEL_DIR']):&#10;        os.makedirs(app.config['MODEL_DIR'])&#10;    joblib.dump(scaler, os.path.join(app.config['MODEL_DIR'], 'scaler.pkl'))&#10;    joblib.dump(encoder, os.path.join(app.config['MODEL_DIR'], 'encoder.pkl'))&#10;&#10;&#10;def load_model():&#10;    &quot;&quot;&quot;Tải model đã được huấn luyện.&quot;&quot;&quot;&#10;    global ai_model, scaler, encoder&#10;    try:&#10;        ai_model = tf.keras.models.load_model(os.path.join(app.config['MODEL_DIR'], 'persona_model.h5'))&#10;        scaler = joblib.load(os.path.join(app.config['MODEL_DIR'], 'scaler.pkl'))&#10;        encoder = joblib.load(os.path.join(app.config['MODEL_DIR'], 'encoder.pkl'))&#10;        print(f&quot;Đã tải Model AI từ {app.config['MODEL_DIR']}&quot;)&#10;    except (IOError, OSError) as e:&#10;        print(f&quot;Lỗi khi tải model: {e}. Tạo model mới...&quot;)&#10;        train_and_save_model()&#10;&#10;&#10;def get_customer_360_profile(customer_id):&#10;    &quot;&quot;&quot;Lấy hồ sơ 360° từ MySQL.&quot;&quot;&quot;&#10;    customer = Customer.query.filter_by(customer_id=customer_id).first()&#10;    if not customer:&#10;        return None&#10;&#10;    # HDBank summary&#10;    hdbank_transactions = HDBankTransaction.query.filter_by(customer_id=customer_id).all()&#10;    hdbank_summary = {}&#10;    if hdbank_transactions:&#10;        balances = [float(t.balance) for t in hdbank_transactions]&#10;        amounts = [float(t.amount) for t in hdbank_transactions]&#10;        hdbank_summary = {&#10;            'total_transactions': len(hdbank_transactions),&#10;            'average_balance': sum(balances) / len(balances),&#10;            'total_credit_last_3m': sum(float(t.amount) for t in hdbank_transactions if t.transaction_type == 'credit'),&#10;            'total_debit_last_3m': sum(float(t.amount) for t in hdbank_transactions if t.transaction_type == 'debit')&#10;        }&#10;&#10;    # Vietjet summary&#10;    vietjet_flights = VietjetFlight.query.filter_by(customer_id=customer_id).all()&#10;    vietjet_summary = {}&#10;    if vietjet_flights:&#10;        vietjet_summary = {&#10;            'total_flights_last_year': len(vietjet_flights),&#10;            'total_spending': sum(float(f.booking_value) for f in vietjet_flights),&#10;            'is_business_flyer': any(f.ticket_class == 'business' for f in vietjet_flights),&#10;            'favorite_route': f&quot;{vietjet_flights[0].origin}-{vietjet_flights[0].destination}&quot; if vietjet_flights else &quot;N/A&quot;&#10;        }&#10;&#10;    # Resort summary&#10;    resort_bookings = ResortBooking.query.filter_by(customer_id=customer_id).all()&#10;    resort_summary = {}&#10;    if resort_bookings:&#10;        resort_summary = {&#10;            'total_bookings': len(resort_bookings),&#10;            'total_nights_stayed': sum(r.nights_stayed for r in resort_bookings),&#10;            'total_spending': sum(float(r.booking_value) for r in resort_bookings),&#10;            'favorite_resort': resort_bookings[0].resort_name if resort_bookings else &quot;N/A&quot;&#10;        }&#10;&#10;    return {&#10;        'basic_info': {&#10;            'customer_id': customer.customer_id,&#10;            'name': customer.name,&#10;            'age': customer.age,&#10;            'gender': customer.gender,&#10;            'job': customer.job,&#10;            'city': customer.city&#10;        },&#10;        'hdbank_summary': hdbank_summary,&#10;        'vietjet_summary': vietjet_summary,&#10;        'resort_summary': resort_summary&#10;    }&#10;&#10;&#10;@app.route('/api/nft/&lt;int:customer_id&gt;/achievements', methods=['GET'])&#10;def get_customer_achievements_api(customer_id):&#10;    &quot;&quot;&quot;API để lấy danh sách thành tựu của khách hàng cho NFT Passport&quot;&quot;&quot;&#10;    try:&#10;        # Query tất cả achievements của customer&#10;        customer_achievements = db.session.query(&#10;            CustomerAchievement, Achievement&#10;        ).join(Achievement).filter(&#10;            CustomerAchievement.customer_id == customer_id&#10;        ).all()&#10;&#10;        achievements = []&#10;        for ca, achievement in customer_achievements:&#10;            achievements.append({&#10;                'id': achievement.id,&#10;                'name': achievement.name,&#10;                'description': achievement.description,&#10;                'badge_image_url': achievement.badge_image_url,&#10;                'unlocked_at': ca.unlocked_at.isoformat() if ca.unlocked_at else None&#10;            })&#10;&#10;        return jsonify({&#10;            'customer_id': customer_id,&#10;            'achievements': achievements,&#10;            'total_achievements': len(achievements)&#10;        })&#10;&#10;    except Exception as e:&#10;        return jsonify({'error': f'Lỗi khi lấy thành tựu: {str(e)}'}), 500&#10;&#10;&#10;@app.route('/api/admin/assign-achievement', methods=['POST'])&#10;@require_auth&#10;def assign_achievement_to_customer():&#10;    &quot;&quot;&quot;API cho Admin/Chuyên viên để gán achievement cho khách hàng&quot;&quot;&quot;&#10;    try:&#10;        # Kiểm tra quyền admin&#10;        user = request.current_user&#10;        if user.role != 'admin':&#10;            return jsonify({'error': 'Chỉ admin mới có quyền gán thành tựu'}), 403&#10;&#10;        data = request.get_json()&#10;        customer_id = data.get('customer_id')&#10;        achievement_id = data.get('achievement_id')&#10;        admin_note = data.get('admin_note', '')&#10;&#10;        if not customer_id or not achievement_id:&#10;            return jsonify({'error': 'Thiếu customer_id hoặc achievement_id'}), 400&#10;&#10;        # Kiểm tra customer tồn tại&#10;        customer = Customer.query.filter_by(customer_id=customer_id).first()&#10;        if not customer:&#10;            return jsonify({'error': f'Khách hàng {customer_id} không tồn tại'}), 404&#10;&#10;        # Kiểm tra achievement tồn tại&#10;        achievement = Achievement.query.get(achievement_id)&#10;        if not achievement:&#10;            return jsonify({'error': f'Achievement {achievement_id} không tồn tại'}), 404&#10;&#10;        # Kiểm tra điều kiện đạt achievement&#10;        def check_eligibility(achievement, customer):&#10;            # Lấy số chuyến bay thực tế&#10;            flight_count = VietjetFlight.query.filter_by(customer_id=customer.customer_id).count()&#10;            # Lấy số dư trung bình thực tế&#10;            avg_balance = db.session.query(db.func.avg(HDBankTransaction.balance)).filter_by(&#10;                customer_id=customer.customer_id).scalar() or 0&#10;            # Lấy số đêm resort&#10;            resort_nights = db.session.query(db.func.sum(ResortBooking.nights_stayed)).filter_by(&#10;                customer_id=customer.customer_id).scalar() or 0&#10;&#10;            if 'Phi công Đồng' in achievement.name:&#10;                return flight_count &gt;= 5&#10;            elif 'Phi công Bạc' in achievement.name:&#10;                return flight_count &gt;= 10&#10;            elif 'Phi công Vàng' in achievement.name:&#10;                return flight_count &gt;= 20&#10;            elif 'Khách hàng VIP' in achievement.name:&#10;                return avg_balance &gt;= 200000000&#10;            elif 'Nhà đầu tư thông minh' in achievement.name:&#10;                return avg_balance &gt;= 500000000&#10;            elif 'Người du lịch' in achievement.name:&#10;                return resort_nights &gt;= 10&#10;            elif 'Người tiên phong' in achievement.name:&#10;                return False  # SVT balance chưa implement&#10;            return True  # Cho các achievement khác&#10;&#10;        if not check_eligibility(achievement, customer):&#10;            # Lấy thông tin hiện tại để hiển thị trong lỗi&#10;            flight_count = VietjetFlight.query.filter_by(customer_id=customer.customer_id).count()&#10;            avg_balance = db.session.query(db.func.avg(HDBankTransaction.balance)).filter_by(&#10;                customer_id=customer.customer_id).scalar() or 0&#10;            return jsonify({&#10;                'error': f'Khách hàng chưa đủ điều kiện cho &quot;{achievement.name}&quot;. Hiện tại: {flight_count} chuyến bay, {avg_balance:,.0f} VND'&#10;            }), 400&#10;&#10;        # Kiểm tra đã có achievement này chưa&#10;        existing = CustomerAchievement.query.filter_by(&#10;            customer_id=customer_id,&#10;            achievement_id=achievement_id&#10;        ).first()&#10;&#10;        if existing:&#10;            return jsonify({&#10;                'error': f'Khách hàng đã có achievement &quot;{achievement.name}&quot; rồi'&#10;            }), 400&#10;&#10;        # Gán achievement cho customer&#10;        customer_achievement = CustomerAchievement(&#10;            customer_id=customer_id,&#10;            achievement_id=achievement_id,&#10;            unlocked_at=datetime.datetime.utcnow()&#10;        )&#10;        db.session.add(customer_achievement)&#10;&#10;        # Thêm SVT token reward&#10;        svt_reward = 1000  # Default reward&#10;        if 'Phi công Vàng' in achievement.name:&#10;            svt_reward = 2000&#10;        elif 'Phi công Bạc' in achievement.name:&#10;            svt_reward = 1500&#10;        elif 'VIP' in achievement.name:&#10;            svt_reward = 1500&#10;&#10;        # Tạo token transaction&#10;        token_tx = TokenTransaction(&#10;            customer_id=customer_id,&#10;            transaction_type=&quot;achievement_reward&quot;,&#10;            amount=svt_reward,&#10;            description=f&quot;Admin gán thành tựu: {achievement.name}&quot;,&#10;            tx_hash=f&quot;0x{uuid.uuid4().hex}&quot;,&#10;            block_number=random.randint(1000000, 2000000)&#10;        )&#10;        db.session.add(token_tx)&#10;&#10;        db.session.commit()&#10;&#10;        return jsonify({&#10;            'success': True,&#10;            'message': f'Đã gán thành tựu &quot;{achievement.name}&quot; cho {customer.name}',&#10;            'customer_id': customer_id,&#10;            'customer_name': customer.name,&#10;            'achievement': {&#10;                'id': achievement.id,&#10;                'name': achievement.name,&#10;                'description': achievement.description,&#10;                'badge_image_url': achievement.badge_image_url&#10;            },&#10;            'svt_reward': svt_reward,&#10;            'assigned_by': user.email,&#10;            'assigned_at': customer_achievement.unlocked_at.isoformat()&#10;        })&#10;&#10;    except Exception as e:&#10;        db.session.rollback()&#10;        return jsonify({'error': f'Lỗi gán thành tựu: {str(e)}'}), 500&#10;&#10;&#10;@app.route('/api/admin/achievements', methods=['GET'])&#10;@require_auth&#10;def get_all_achievements():&#10;    &quot;&quot;&quot;API để lấy danh sách tất cả achievements có sẵn (cho admin)&quot;&quot;&quot;&#10;    try:&#10;        # Kiểm tra quyền admin&#10;        user = request.current_user&#10;        if user.role != 'admin':&#10;            return jsonify({'error': 'Chỉ admin mới có quyền xem danh sách achievements'}), 403&#10;&#10;        achievements = Achievement.query.all()&#10;&#10;        achievement_list = []&#10;        for achievement in achievements:&#10;            # Đếm số customer đã có achievement này&#10;            customer_count = CustomerAchievement.query.filter_by(&#10;                achievement_id=achievement.id&#10;            ).count()&#10;&#10;            achievement_list.append({&#10;                'id': achievement.id,&#10;                'name': achievement.name,&#10;                'description': achievement.description,&#10;                'badge_image_url': achievement.badge_image_url,&#10;                'customer_count': customer_count,&#10;                'created_at': achievement.created_at.isoformat() if achievement.created_at else None&#10;            })&#10;&#10;        return jsonify({&#10;            'success': True,&#10;            'achievements': achievement_list,&#10;            'total': len(achievement_list)&#10;        })&#10;&#10;    except Exception as e:&#10;        return jsonify({'error': f'Lỗi lấy danh sách achievements: {str(e)}'}), 500&#10;&#10;&#10;@app.route('/api/admin/create-achievement', methods=['POST'])&#10;@require_auth&#10;def create_new_achievement():&#10;    &quot;&quot;&quot;API cho Admin tạo achievement mới&quot;&quot;&quot;&#10;    try:&#10;        # Kiểm tra quyền admin&#10;        user = request.current_user&#10;        if user.role != 'admin':&#10;            return jsonify({'error': 'Chỉ admin mới có quyền tạo achievement'}), 403&#10;&#10;        data = request.get_json()&#10;        name = data.get('name')&#10;        description = data.get('description')&#10;        badge_image_url = data.get('badge_image_url', '/static/badges/default.png')&#10;&#10;        if not name or not description:&#10;            return jsonify({'error': 'Thiếu tên hoặc mô tả achievement'}), 400&#10;&#10;        # Kiểm tra tên đã tồn tại chưa&#10;        existing = Achievement.query.filter_by(name=name).first()&#10;        if existing:&#10;            return jsonify({'error': f'Achievement &quot;{name}&quot; đã tồn tại'}), 400&#10;&#10;        # Tạo achievement mới&#10;        new_achievement = Achievement(&#10;            name=name,&#10;            description=description,&#10;            badge_image_url=badge_image_url&#10;        )&#10;        db.session.add(new_achievement)&#10;        db.session.commit()&#10;&#10;        print(f&quot; Admin {user.email} tạo achievement mới: {name}&quot;)&#10;&#10;        return jsonify({&#10;            'success': True,&#10;            'message': f'Đã tạo achievement &quot;{name}&quot; thành công',&#10;            'achievement': {&#10;                'id': new_achievement.id,&#10;                'name': new_achievement.name,&#10;                'description': new_achievement.description,&#10;                'badge_image_url': new_achievement.badge_image_url,&#10;                'created_at': new_achievement.created_at.isoformat()&#10;            },&#10;            'created_by': user.email&#10;        })&#10;&#10;    except Exception as e:&#10;        db.session.rollback()&#10;        return jsonify({'error': f'Lỗi tạo achievement: {str(e)}'}), 500&#10;&#10;&#10;@app.route('/api/admin/customer/&lt;int:customer_id&gt;/achievements', methods=['GET'])&#10;@require_auth&#10;def get_customer_achievements_for_admin(customer_id):&#10;    &quot;&quot;&quot;API cho Admin xem tất cả achievements của khách hàng cụ thể&quot;&quot;&quot;&#10;    try:&#10;        # Kiểm tra quyền admin&#10;        user = request.current_user&#10;        if user.role != 'admin':&#10;            return jsonify({'error': 'Chỉ admin mới có quyền xem'}), 403&#10;&#10;        # Kiểm tra customer tồn tại&#10;        customer = Customer.query.filter_by(customer_id=customer_id).first()&#10;        if not customer:&#10;            return jsonify({'error': f'Khách hàng {customer_id} không tồn tại'}), 404&#10;&#10;        # Lấy tất cả achievements có sẵn&#10;        all_achievements = Achievement.query.all()&#10;&#10;        # Lấy achievements đã có của customer&#10;        customer_achievements = db.session.query(CustomerAchievement).filter_by(&#10;            customer_id=customer_id&#10;        ).all()&#10;&#10;        achieved_ids = {ca.achievement_id for ca in customer_achievements}&#10;&#10;        # Phân loại achievements&#10;        achieved_list = []&#10;        available_list = []&#10;&#10;        for achievement in all_achievements:&#10;            achievement_data = {&#10;                'id': achievement.id,&#10;                'name': achievement.name,&#10;                'description': achievement.description,&#10;                'badge_image_url': achievement.badge_image_url&#10;            }&#10;&#10;            if achievement.id in achieved_ids:&#10;                # Tìm thông tin unlock&#10;                ca = next(ca for ca in customer_achievements if ca.achievement_id == achievement.id)&#10;                achievement_data['unlocked_at'] = ca.unlocked_at.isoformat() if ca.unlocked_at else None&#10;                achieved_list.append(achievement_data)&#10;            else:&#10;                available_list.append(achievement_data)&#10;&#10;        # Thống kê hoạt động của customer&#10;        total_flights = VietjetFlight.query.filter_by(customer_id=customer_id).count()&#10;        total_resort_nights = db.session.query(db.func.sum(ResortBooking.nights_stayed)).filter_by(&#10;            customer_id=customer_id).scalar() or 0&#10;        avg_balance = db.session.query(db.func.avg(HDBankTransaction.balance)).filter_by(&#10;            customer_id=customer_id).scalar() or 0&#10;&#10;        return jsonify({&#10;            'success': True,&#10;            'customer': {&#10;                'customer_id': customer_id,&#10;                'name': customer.name,&#10;                'age': customer.age,&#10;                'city': customer.city,&#10;                'persona_type': customer.persona_type&#10;            },&#10;            'achievements': {&#10;                'achieved': achieved_list,&#10;                'available_to_assign': available_list,&#10;                'total_achieved': len(achieved_list),&#10;                'total_available': len(available_list)&#10;            },&#10;            'customer_stats': {&#10;                'total_flights': total_flights,&#10;                'total_resort_nights': int(total_resort_nights),&#10;                'avg_balance': float(avg_balance),&#10;                'member_since': customer.created_at.strftime('%Y-%m-%d') if customer.created_at else None&#10;            },&#10;            'suggested_achievements': get_suggested_achievements_for_customer(customer_id, total_flights,&#10;                                                                              total_resort_nights, avg_balance)&#10;        })&#10;&#10;    except Exception as e:&#10;        return jsonify({'error': f'Lỗi lấy thông tin: {str(e)}'}), 500&#10;&#10;&#10;def get_suggested_achievements_for_customer(customer_id, total_flights, total_resort_nights, avg_balance):&#10;    &quot;&quot;&quot;Gợi ý achievements phù hợp cho khách hàng dựa trên hoạt động&quot;&quot;&quot;&#10;    suggestions = []&#10;&#10;    # Kiểm tra các achievements đã có&#10;    existing_achievements = db.session.query(CustomerAchievement.achievement_id).filter_by(&#10;        customer_id=customer_id&#10;    ).all()&#10;    existing_ids = {ea.achievement_id for ea in existing_achievements}&#10;&#10;    # Logic gợi ý dựa trên hoạt động&#10;    if total_flights &gt;= 20:&#10;        # Gợi ý Phi công Vàng nếu chưa có&#10;        gold_pilot = Achievement.query.filter_by(name='Phi công Vàng').first()&#10;        if gold_pilot and gold_pilot.id not in existing_ids:&#10;            suggestions.append({&#10;                'achievement_id': gold_pilot.id,&#10;                'achievement_name': gold_pilot.name,&#10;                'reason': f'Khách hàng đã bay {total_flights} chuyến (≥20 chuyến)',&#10;                'confidence': 'high'&#10;            })&#10;    elif total_flights &gt;= 10:&#10;        # Gợi ý Phi công Bạc&#10;        silver_pilot = Achievement.query.filter_by(name='Phi công Bạc').first()&#10;        if silver_pilot and silver_pilot.id not in existing_ids:&#10;            suggestions.append({&#10;                'achievement_id': silver_pilot.id,&#10;                'achievement_name': silver_pilot.name,&#10;                'reason': f'Khách hàng đã bay {total_flights} chuyến (≥10 chuyến)',&#10;                'confidence': 'high'&#10;            })&#10;    elif total_flights &gt;= 5:&#10;        # Gợi ý Phi công Đồng&#10;        bronze_pilot = Achievement.query.filter_by(name='Phi công Đồng').first()&#10;        if bronze_pilot and bronze_pilot.id not in existing_ids:&#10;            suggestions.append({&#10;                'achievement_id': bronze_pilot.id,&#10;                'achievement_name': bronze_pilot.name,&#10;                'reason': f'Khách hàng đã bay {total_flights} chuyến (≥5 chuyến)',&#10;                'confidence': 'high'&#10;            })&#10;&#10;    # Gợi ý dựa trên số dư&#10;    if avg_balance &gt;= 100000000:  # ≥ 100 triệu&#10;        vip_achievement = Achievement.query.filter_by(name='Khách hàng VIP').first()&#10;        if vip_achievement and vip_achievement.id not in existing_ids:&#10;            suggestions.append({&#10;                'achievement_id': vip_achievement.id,&#10;                'achievement_name': vip_achievement.name,&#10;                'reason': f'Số dư trung bình {avg_balance:,.0f} VNĐ (≥100 triệu)',&#10;                'confidence': 'high'&#10;            })&#10;&#10;    # Gợi ý dựa trên nghỉ dưỡng&#10;    if total_resort_nights &gt;= 10:&#10;        traveler_achievement = Achievement.query.filter_by(name='Người du lịch').first()&#10;        if traveler_achievement and traveler_achievement.id not in existing_ids:&#10;            suggestions.append({&#10;                'achievement_id': traveler_achievement.id,&#10;                'achievement_name': traveler_achievement.name,&#10;                'reason': f'Đã nghỉ dưỡng {total_resort_nights} đêm (≥10 đêm)',&#10;                'confidence': 'medium'&#10;            })&#10;&#10;    return suggestions[:5]  # Giới hạn 5 gợi ý&#10;&#10;&#10;@app.route('/api/admin/bulk-assign-achievements', methods=['POST'])&#10;@require_auth&#10;def bulk_assign_achievements():&#10;    &quot;&quot;&quot;API gán achievements hàng loạt cho nhiều khách hàng&quot;&quot;&quot;&#10;    try:&#10;        # Kiểm tra quyền admin&#10;        user = request.current_user&#10;        if user.role != 'admin':&#10;            return jsonify({'error': 'Chỉ admin mới có quyền gán hàng loạt'}), 403&#10;&#10;        data = request.get_json()&#10;        customer_ids = data.get('customer_ids', [])&#10;        achievement_id = data.get('achievement_id')&#10;        admin_note = data.get('admin_note', 'Bulk assignment')&#10;&#10;        if not customer_ids or not achievement_id:&#10;            return jsonify({'error': 'Thiếu customer_ids hoặc achievement_id'}), 400&#10;&#10;        # Kiểm tra achievement tồn tại&#10;        achievement = Achievement.query.get(achievement_id)&#10;        if not achievement:&#10;            return jsonify({'error': f'Achievement {achievement_id} không tồn tại'}), 404&#10;&#10;        success_count = 0&#10;        errors = []&#10;&#10;        for customer_id in customer_ids:&#10;            try:&#10;                # Kiểm tra customer tồn tại&#10;                customer = Customer.query.filter_by(customer_id=customer_id).first()&#10;                if not customer:&#10;                    errors.append(f'Customer {customer_id}: không tồn tại')&#10;                    continue&#10;&#10;                # Kiểm tra đã có achievement chưa&#10;                existing = CustomerAchievement.query.filter_by(&#10;                    customer_id=customer_id,&#10;                    achievement_id=achievement_id&#10;                ).first()&#10;&#10;                if existing:&#10;                    errors.append(f'Customer {customer_id}: đã có achievement này')&#10;                    continue&#10;&#10;                # Gán achievement&#10;                customer_achievement = CustomerAchievement(&#10;                    customer_id=customer_id,&#10;                    achievement_id=achievement_id,&#10;                    unlocked_at=datetime.datetime.utcnow()&#10;                )&#10;                db.session.add(customer_achievement)&#10;&#10;                # Thêm SVT reward&#10;                svt_reward = 500  # Default reward for bulk assignment&#10;                token_tx = TokenTransaction(&#10;                    customer_id=customer_id,&#10;                    transaction_type=&quot;achievement_reward&quot;,&#10;                    amount=svt_reward,&#10;                    description=f&quot;Bulk assignment: {achievement.name}&quot;,&#10;                    tx_hash=f&quot;0x{uuid.uuid4().hex}&quot;,&#10;                    block_number=random.randint(1000000, 2000000)&#10;                )&#10;                db.session.add(token_tx)&#10;&#10;                success_count += 1&#10;&#10;            except Exception as e:&#10;                errors.append(f'Customer {customer_id}: {str(e)}')&#10;&#10;        db.session.commit()&#10;&#10;        print(f&quot; Admin {user.email} bulk assigned '{achievement.name}' to {success_count} customers&quot;)&#10;&#10;        return jsonify({&#10;            'success': True,&#10;            'message': f'Đã gán &quot;{achievement.name}&quot; cho {success_count} khách hàng',&#10;            'achievement_name': achievement.name,&#10;            'success_count': success_count,&#10;            'total_requested': len(customer_ids),&#10;            'errors': errors,&#10;            'assigned_by': user.email&#10;        })&#10;&#10;    except Exception as e:&#10;        db.session.rollback()&#10;        return jsonify({'error': f'Lỗi gán hàng loạt: {str(e)}'}), 500&#10;&#10;&#10;@app.route('/api/admin/auto-assign-achievements/&lt;int:customer_id&gt;', methods=['POST'])&#10;@require_auth&#10;def auto_assign_achievements(customer_id):&#10;    &quot;&quot;&quot;API tự động phân tích và gán achievements cho khách hàng dựa trên dữ liệu thực tế&quot;&quot;&quot;&#10;    try:&#10;        # Kiểm tra quyền admin&#10;        user = request.current_user&#10;        if user.role != 'admin':&#10;            return jsonify({'error': 'Chỉ admin mới có quyền tự động gán achievements'}), 403&#10;&#10;        # Kiểm tra customer tồn tại&#10;        customer = Customer.query.filter_by(customer_id=customer_id).first()&#10;        if not customer:&#10;            return jsonify({'error': f'Khách hàng {customer_id} không tồn tại'}), 404&#10;&#10;        # Thu thập dữ liệu thực tế của khách hàng&#10;        total_flights = VietjetFlight.query.filter_by(customer_id=customer_id).count()&#10;        avg_balance = db.session.query(db.func.avg(HDBankTransaction.balance)).filter_by(&#10;            customer_id=customer_id).scalar() or 0&#10;        total_resort_nights = db.session.query(db.func.sum(ResortBooking.nights_stayed)).filter_by(&#10;            customer_id=customer_id).scalar() or 0&#10;&#10;        # Lấy achievements đã có&#10;        existing_achievements = db.session.query(CustomerAchievement.achievement_id).filter_by(&#10;            customer_id=customer_id&#10;        ).all()&#10;        existing_ids = {ea.achievement_id for ea in existing_achievements}&#10;&#10;        # Logic tự động gán achievements&#10;        assigned_achievements = []&#10;        total_svt_reward = 0&#10;&#10;        # 1. Achievements bay&#10;        if total_flights &gt;= 20:&#10;            gold_pilot = Achievement.query.filter_by(name='Phi công Vàng').first()&#10;            if gold_pilot and gold_pilot.id not in existing_ids:&#10;                # Gán achievement&#10;                ca = CustomerAchievement(&#10;                    customer_id=customer_id,&#10;                    achievement_id=gold_pilot.id,&#10;                    unlocked_at=datetime.datetime.utcnow()&#10;                )&#10;                db.session.add(ca)&#10;&#10;                # Thêm SVT reward&#10;                token_tx = TokenTransaction(&#10;                    customer_id=customer_id,&#10;                    transaction_type=&quot;auto_achievement_reward&quot;,&#10;                    amount=2000,&#10;                    description=f&quot;Tự động gán: {gold_pilot.name}&quot;,&#10;                    tx_hash=f&quot;0x{uuid.uuid4().hex}&quot;,&#10;                    block_number=random.randint(1000000, 2000000)&#10;                )&#10;                db.session.add(token_tx)&#10;&#10;                assigned_achievements.append(gold_pilot.name)&#10;                total_svt_reward += 2000&#10;&#10;        elif total_flights &gt;= 10:&#10;            silver_pilot = Achievement.query.filter_by(name='Phi công Bạc').first()&#10;            if silver_pilot and silver_pilot.id not in existing_ids:&#10;                # Gán achievement&#10;                ca = CustomerAchievement(&#10;                    customer_id=customer_id,&#10;                    achievement_id=silver_pilot.id,&#10;                    unlocked_at=datetime.datetime.utcnow()&#10;                )&#10;                db.session.add(ca)&#10;&#10;                # Thêm SVT reward&#10;                token_tx = TokenTransaction(&#10;                    customer_id=customer_id,&#10;                    transaction_type=&quot;auto_achievement_reward&quot;,&#10;                    amount=1500,&#10;                    description=f&quot;Tự động gán: {silver_pilot.name}&quot;,&#10;                    tx_hash=f&quot;0x{uuid.uuid4().hex}&quot;,&#10;                    block_number=random.randint(1000000, 2000000)&#10;                )&#10;                db.session.add(token_tx)&#10;&#10;                assigned_achievements.append(silver_pilot.name)&#10;                total_svt_reward += 1500&#10;&#10;        elif total_flights &gt;= 5:&#10;            bronze_pilot = Achievement.query.filter_by(name='Phi công Đồng').first()&#10;            if bronze_pilot and bronze_pilot.id not in existing_ids:&#10;                # Gán achievement&#10;                ca = CustomerAchievement(&#10;                    customer_id=customer_id,&#10;                    achievement_id=bronze_pilot.id,&#10;                    unlocked_at=datetime.datetime.utcnow()&#10;                )&#10;                db.session.add(ca)&#10;&#10;                # Thêm SVT reward&#10;                token_tx = TokenTransaction(&#10;                    customer_id=customer_id,&#10;                    transaction_type=&quot;auto_achievement_reward&quot;,&#10;                    amount=1000,&#10;                    description=f&quot;Tự động gán: {bronze_pilot.name}&quot;,&#10;                    tx_hash=f&quot;0x{uuid.uuid4().hex}&quot;,&#10;                    block_number=random.randint(1000000, 2000000)&#10;                )&#10;                db.session.add(token_tx)&#10;&#10;                assigned_achievements.append(bronze_pilot.name)&#10;                total_svt_reward += 1000&#10;&#10;        # 2. VIP achievement&#10;        if avg_balance &gt;= 100000000:  # ≥ 100 triệu&#10;            vip_achievement = Achievement.query.filter_by(name='Khách hàng VIP').first()&#10;            if vip_achievement and vip_achievement.id not in existing_ids:&#10;                # Gán achievement&#10;                ca = CustomerAchievement(&#10;                    customer_id=customer_id,&#10;                    achievement_id=vip_achievement.id,&#10;                    unlocked_at=datetime.datetime.utcnow()&#10;                )&#10;                db.session.add(ca)&#10;&#10;                # Thêm SVT reward&#10;                token_tx = TokenTransaction(&#10;                    customer_id=customer_id,&#10;                    transaction_type=&quot;auto_achievement_reward&quot;,&#10;                    amount=1500,&#10;                    description=f&quot;Tự động gán: {vip_achievement.name}&quot;,&#10;                    tx_hash=f&quot;0x{uuid.uuid4().hex}&quot;,&#10;                    block_number=random.randint(1000000, 2000000)&#10;                )&#10;                db.session.add(token_tx)&#10;&#10;                assigned_achievements.append(vip_achievement.name)&#10;                total_svt_reward += 1500&#10;&#10;        # 3. Du lịch achievement&#10;        if total_resort_nights &gt;= 10:&#10;            traveler_achievement = Achievement.query.filter_by(name='Người du lịch').first()&#10;            if traveler_achievement and traveler_achievement.id not in existing_ids:&#10;                # Gán achievement&#10;                ca = CustomerAchievement(&#10;                    customer_id=customer_id,&#10;                    achievement_id=traveler_achievement.id,&#10;                    unlocked_at=datetime.datetime.utcnow()&#10;                )&#10;                db.session.add(ca)&#10;&#10;                # Thêm SVT reward&#10;                token_tx = TokenTransaction(&#10;                    customer_id=customer_id,&#10;                    transaction_type=&quot;auto_achievement_reward&quot;,&#10;                    amount=800,&#10;                    description=f&quot;Tự động gán: {traveler_achievement.name}&quot;,&#10;                    tx_hash=f&quot;0x{uuid.uuid4().hex}&quot;,&#10;                    block_number=random.randint(1000000, 2000000)&#10;                )&#10;                db.session.add(token_tx)&#10;&#10;                assigned_achievements.append(traveler_achievement.name)&#10;                total_svt_reward += 800&#10;&#10;        db.session.commit()&#10;&#10;        return jsonify({&#10;            'success': True,&#10;            'message': f'Đã tự động gán {len(assigned_achievements)} achievements cho {customer.name}',&#10;            'customer': {&#10;                'customer_id': customer_id,&#10;                'name': customer.name&#10;            },&#10;            'assigned_achievements': assigned_achievements,&#10;            'total_svt_reward': total_svt_reward,&#10;            'analysis_data': {&#10;                'total_flights': total_flights,&#10;                'avg_balance': float(avg_balance),&#10;                'total_resort_nights': int(total_resort_nights)&#10;            }&#10;        })&#10;&#10;    except Exception as e:&#10;        db.session.rollback()&#10;        return jsonify({'error': f'Lỗi tự động gán achievements: {str(e)}'}), 500&#10;&#10;&#10;@app.route('/admin/achievements', methods=['GET'])&#10;def get_all_achievements_simple():&#10;    &quot;&quot;&quot;API lấy tất cả achievements (không cần auth)&quot;&quot;&quot;&#10;    try:&#10;        achievements = Achievement.query.all()&#10;&#10;        achievement_list = []&#10;        for achievement in achievements:&#10;            # Đếm số customer đã có achievement này&#10;            customer_count = CustomerAchievement.query.filter_by(&#10;                achievement_id=achievement.id&#10;            ).count()&#10;&#10;            achievement_list.append({&#10;                'id': achievement.id,&#10;                'name': achievement.name,&#10;                'description': achievement.description,&#10;                'badge_image_url': achievement.badge_image_url,&#10;                'customer_count': customer_count,&#10;                'created_at': achievement.created_at.isoformat() if achievement.created_at else None&#10;            })&#10;&#10;        return jsonify({&#10;            'success': True,&#10;            'achievements': achievement_list,&#10;            'total': len(achievement_list)&#10;        })&#10;&#10;    except Exception as e:&#10;        return jsonify({'error': f'Lỗi lấy danh sách achievements: {str(e)}'}), 500&#10;&#10;&#10;# =============================================================================&#10;# MAIN&#10;# =============================================================================&#10;if __name__ == '__main__':&#10;    print(&quot;Khởi động One-Sovico Platform...&quot;)&#10;    print(f&quot;Database: {Config.get_database_url()}&quot;)&#10;&#10;    init_app()&#10;&#10;    print(&quot;Server đang chạy tại: http://127.0.0.1:5000&quot;)&#10;    app.run(debug=True, port=5000)&#10;&#10;" />
              <option name="updatedContent" value="# app.py&#10;# -*- coding: utf-8 -*-&#10;&#10;from flask import Flask, jsonify, request, send_from_directory&#10;from flask_cors import CORS&#10;from flask_sqlalchemy import SQLAlchemy&#10;from flask_bcrypt import Bcrypt&#10;import jwt&#10;import datetime&#10;import time&#10;import uuid&#10;import random&#10;from functools import wraps&#10;import pandas as pd&#10;import numpy as np&#10;import tensorflow as tf&#10;from sklearn.preprocessing import StandardScaler, OneHotEncoder&#10;import joblib&#10;import os&#10;import matplotlib&#10;from config import Config&#10;&#10;matplotlib.use('Agg')  # Backend không GUI cho matplotlib&#10;import matplotlib.pyplot as plt&#10;&#10;# Import blockchain integration for NFT achievements&#10;try:&#10;    from blockchain_simple import update_nft_on_blockchain, get_nft_metadata&#10;    from blockchain_config import (&#10;        evaluate_all_achievements,&#10;        get_highest_rank_from_achievements,&#10;        ACHIEVEMENT_CONFIG&#10;    )&#10;&#10;    BLOCKCHAIN_ENABLED = True&#10;    print(&quot;Blockchain integration loaded successfully&quot;)&#10;except ImportError as e:&#10;    print(f&quot;Blockchain integration not available: {e}&quot;)&#10;    BLOCKCHAIN_ENABLED = False&#10;&#10;# Import mission progression system&#10;try:&#10;    from mission_progression import mission_system, get_missions_for_customer&#10;    from detailed_missions import DetailedMissionSystem&#10;&#10;    MISSION_SYSTEM_ENABLED = True&#10;    print(&quot;Mission progression system loaded successfully&quot;)&#10;except ImportError as e:&#10;    print(f&quot;Mission progression system not available: {e}&quot;)&#10;    MISSION_SYSTEM_ENABLED = False&#10;&#10;# =============================================================================&#10;# KHỞI TẠO VÀ CẤU HÌNH&#10;# =============================================================================&#10;app = Flask(__name__)&#10;app.config.from_object(Config)&#10;&#10;# Initialize detailed mission system&#10;detailed_mission_system = DetailedMissionSystem()&#10;&#10;db = SQLAlchemy(app)&#10;bcrypt = Bcrypt(app)&#10;cors = CORS(app)&#10;&#10;# Biến toàn cục cho AI model&#10;ai_model = None&#10;scaler = None&#10;encoder = None&#10;feature_columns = ['age', 'avg_balance', 'total_flights', 'is_business_flyer_int', 'total_nights_stayed',&#10;                   'total_resort_spending']&#10;&#10;&#10;# =============================================================================&#10;# DATABASE MODELS&#10;# =============================================================================&#10;class User(db.Model):&#10;    __tablename__ = 'users'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    email = db.Column(db.String(120), unique=True, nullable=False)&#10;    name = db.Column(db.String(100), nullable=False)&#10;    password_hash = db.Column(db.String(255), nullable=False)&#10;    role = db.Column(db.Enum('admin', 'customer'), default='customer')&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.id'), nullable=True)&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;    updated_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)&#10;&#10;    # Relationship to get actual customer record&#10;    customer = db.relationship('Customer', backref='user_accounts')&#10;&#10;    def set_password(self, password):&#10;        self.password_hash = bcrypt.generate_password_hash(password).decode('utf-8')&#10;&#10;    def check_password(self, password):&#10;        return bcrypt.check_password_hash(self.password_hash, password)&#10;&#10;&#10;class Customer(db.Model):&#10;    __tablename__ = 'customers'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    customer_id = db.Column(db.Integer, unique=True, nullable=False)&#10;    name = db.Column(db.String(100), nullable=False)&#10;    age = db.Column(db.Integer)&#10;    gender = db.Column(db.Enum('Nam', 'Nữ', 'Khác'))&#10;    job = db.Column(db.String(100))&#10;    city = db.Column(db.String(100))&#10;    persona_type = db.Column(db.Enum('doanh_nhan', 'gia_dinh', 'nguoi_tre'))&#10;    nft_token_id = db.Column(db.Integer, nullable=True)  # ID của NFT Passport trên blockchain&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;    updated_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)&#10;&#10;&#10;class HDBankTransaction(db.Model):&#10;    __tablename__ = 'hdbank_transactions'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    transaction_id = db.Column(db.String(50), unique=True, nullable=False)&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False)&#10;    transaction_date = db.Column(db.DateTime, nullable=False)&#10;    amount = db.Column(db.Numeric(15, 2), nullable=False)&#10;    # Expanded enum to align with usage across endpoints&#10;    transaction_type = db.Column(db.Enum('credit', 'debit', 'transfer', 'loan_disbursement'), nullable=False)&#10;    # Balance can be null when not tracked on some operations&#10;    balance = db.Column(db.Numeric(15, 2), nullable=True)&#10;    description = db.Column(db.Text)&#10;    status = db.Column(db.String(30), default='completed')&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;&#10;&#10;class HDBankCard(db.Model):&#10;    __tablename__ = 'hdbank_cards'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False, index=True)&#10;    card_id = db.Column(db.String(50), unique=True, nullable=False)&#10;    card_number = db.Column(db.String(20), nullable=False)&#10;    card_type = db.Column(db.Enum('classic', 'gold', 'platinum'), nullable=False)&#10;    card_name = db.Column(db.String(100), nullable=False)&#10;    credit_limit = db.Column(db.BigInteger, nullable=False)&#10;    annual_fee = db.Column(db.BigInteger, nullable=False)&#10;    status = db.Column(db.Enum('active', 'blocked', 'expired'), default='active')&#10;    opened_date = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;    expiry_date = db.Column(db.DateTime, nullable=False)&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;    updated_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)&#10;&#10;    def to_dict(self):&#10;        return {&#10;            'card_id': self.card_id,&#10;            'card_number': f&quot;****-****-****-{self.card_number[-4:]}&quot;,&#10;            'card_type': self.card_type,&#10;            'card_name': self.card_name,&#10;            'credit_limit': self.credit_limit,&#10;            'status': self.status,&#10;            'opened_date': self.opened_date.strftime('%Y-%m-%d'),&#10;            'expiry_date': self.expiry_date.strftime('%Y-%m-%d')&#10;        }&#10;&#10;&#10;class VietjetFlight(db.Model):&#10;    __tablename__ = 'vietjet_flights'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    flight_id = db.Column(db.String(50), unique=True, nullable=False)&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False)&#10;    flight_date = db.Column(db.DateTime, nullable=False)&#10;    origin = db.Column(db.String(10), nullable=False)&#10;    destination = db.Column(db.String(10), nullable=False)&#10;    ticket_class = db.Column(db.Enum('economy', 'business'), nullable=False)&#10;    booking_value = db.Column(db.Numeric(12, 2), nullable=False)&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;&#10;&#10;class ResortBooking(db.Model):&#10;    __tablename__ = 'resort_bookings'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    booking_id = db.Column(db.String(50), unique=True, nullable=False)&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False)&#10;    resort_name = db.Column(db.String(200), nullable=False)&#10;    booking_date = db.Column(db.DateTime, nullable=False)&#10;    nights_stayed = db.Column(db.Integer, nullable=False)&#10;    booking_value = db.Column(db.Numeric(12, 2), nullable=False)&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;&#10;&#10;class TokenTransaction(db.Model):&#10;    __tablename__ = 'token_transactions'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    tx_hash = db.Column(db.String(100), unique=True, nullable=False)&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False)&#10;    transaction_type = db.Column(db.String(50), nullable=False)&#10;    amount = db.Column(db.Numeric(10, 2), nullable=False)&#10;    description = db.Column(db.Text)&#10;    block_number = db.Column(db.Integer)&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;&#10;&#10;# =============================================================================&#10;# ACHIEVEMENTS &amp; NFT PASSPORT MODELS&#10;# =============================================================================&#10;class Achievement(db.Model):&#10;    __tablename__ = 'achievements'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    name = db.Column(db.String(100), nullable=False)  # ví dụ: &quot;Phi công Vàng&quot;&#10;    description = db.Column(db.Text, nullable=False)  # &quot;Bay hơn 20 chuyến trong năm&quot;&#10;    badge_image_url = db.Column(db.String(200))  # Đường dẫn đến hình ảnh huy hiệu&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;&#10;&#10;class CustomerAchievement(db.Model):&#10;    __tablename__ = 'customer_achievements'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False)&#10;    achievement_id = db.Column(db.Integer, db.ForeignKey('achievements.id'), nullable=False)&#10;    unlocked_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;&#10;    # Relationships&#10;    customer = db.relationship('Customer', backref='achievements')&#10;    achievement = db.relationship('Achievement', backref='customers')&#10;&#10;&#10;class CustomerMission(db.Model):&#10;    __tablename__ = 'customer_missions'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False)&#10;    mission_id = db.Column(db.String(100), nullable=False)  # ID từ mission progression system&#10;    mission_title = db.Column(db.String(200), nullable=False)&#10;    mission_category = db.Column(db.String(50), nullable=False)&#10;    mission_level = db.Column(db.String(50), nullable=False)&#10;    status = db.Column(db.Enum('available', 'in_progress', 'completed', 'expired'), default='available')&#10;    progress_data = db.Column(db.JSON)  # Lưu trữ tiến trình chi tiết&#10;    svt_reward = db.Column(db.Numeric(10, 2), default=0)&#10;    started_at = db.Column(db.DateTime, nullable=True)&#10;    completed_at = db.Column(db.DateTime, nullable=True)&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;&#10;    # Relationships&#10;    customer = db.relationship('Customer', backref='missions')&#10;&#10;&#10;class CustomerMissionProgress(db.Model):&#10;    __tablename__ = 'customer_mission_progress'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False)&#10;    mission_id = db.Column(db.String(100), nullable=False)&#10;    requirement_key = db.Column(db.String(100), nullable=False)  # Ví dụ: login_count, transaction_count&#10;    current_value = db.Column(db.Numeric(15, 2), default=0)&#10;    required_value = db.Column(db.Numeric(15, 2), nullable=False)&#10;    is_completed = db.Column(db.Boolean, default=False)&#10;    updated_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)&#10;&#10;    # Relationships&#10;    customer = db.relationship('Customer', backref='mission_progress')&#10;&#10;&#10;# =============================================================================&#10;# MARKETPLACE &amp; P2P MODELS&#10;# =============================================================================&#10;class MarketplaceItem(db.Model):&#10;    __tablename__ = 'marketplace_items'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    name = db.Column(db.String(100), nullable=False)  # &quot;Voucher ăn uống 100K&quot;&#10;    description = db.Column(db.Text)&#10;    price_svt = db.Column(db.Numeric(10, 2), nullable=False)  # Giá bán bằng SVT&#10;    quantity = db.Column(db.Integer, default=0)  # Số lượng còn lại&#10;    partner_brand = db.Column(db.String(50))  # HDBank, Vietjet, Sovico...&#10;    image_url = db.Column(db.String(200))  # Hình ảnh sản phẩm&#10;    is_active = db.Column(db.Boolean, default=True)&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;&#10;&#10;class P2PListing(db.Model):&#10;    __tablename__ = 'p2p_listings'&#10;&#10;    id = db.Column(db.Integer, primary_key=True)&#10;    seller_customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=False)&#10;    item_name = db.Column(db.String(100), nullable=False)&#10;    description = db.Column(db.Text)&#10;    price_svt = db.Column(db.Numeric(10, 2), nullable=False)&#10;    status = db.Column(db.Enum('active', 'sold', 'cancelled'), default='active')&#10;    buyer_customer_id = db.Column(db.Integer, db.ForeignKey('customers.customer_id'), nullable=True)&#10;    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)&#10;    sold_at = db.Column(db.DateTime, nullable=True)&#10;&#10;    # Relationships&#10;    seller = db.relationship('Customer', foreign_keys=[seller_customer_id], backref='p2p_listings')&#10;    buyer = db.relationship('Customer', foreign_keys=[buyer_customer_id], backref='p2p_purchases')&#10;&#10;&#10;# =============================================================================&#10;# AUTH UTILITIES&#10;# =============================================================================&#10;def create_token(user_id: int):&#10;    payload = {&#10;        'sub': user_id,&#10;        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=8)&#10;    }&#10;    return jwt.encode(payload, app.config['SECRET_KEY'], algorithm='HS256')&#10;&#10;&#10;def verify_token(token: str):&#10;    try:&#10;        data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])&#10;        return data.get('sub')&#10;    except Exception:&#10;        return None&#10;&#10;&#10;def require_auth(func):&#10;    @wraps(func)&#10;    def wrapper(*args, **kwargs):&#10;        auth_header = request.headers.get('Authorization', '')&#10;        if not auth_header.startswith('Bearer '):&#10;            return jsonify({'error': 'Unauthorized'}), 401&#10;        token = auth_header.split(' ', 1)[1]&#10;        user_id = verify_token(token)&#10;        if not user_id:&#10;            return jsonify({'error': 'Unauthorized'}), 401&#10;        user = User.query.get(user_id)&#10;        if not user:&#10;            return jsonify({'error': 'Unauthorized'}), 401&#10;        request.current_user = user&#10;        return func(*args, **kwargs)&#10;&#10;    return wrapper&#10;&#10;&#10;# =============================================================================&#10;# AI MODEL UTILITIES&#10;# =============================================================================&#10;def plot_and_save_metrics(history, model_dir):&#10;    &quot;&quot;&quot;Vẽ và lưu biểu đồ accuracy và loss.&quot;&quot;&quot;&#10;    plt.figure(figsize=(12, 5))&#10;    # Biểu đồ Accuracy&#10;    plt.subplot(1, 2, 1)&#10;    plt.plot(history.history['accuracy'], label='Training Accuracy')&#10;    plt.title('Model Accuracy')&#10;    plt.ylabel('Accuracy')&#10;    plt.xlabel('Epoch')&#10;    plt.legend(loc='lower right')&#10;    # Biểu đồ Loss&#10;    plt.subplot(1, 2, 2)&#10;    plt.plot(history.history['loss'], label='Training Loss')&#10;    plt.title('Model Loss')&#10;    plt.ylabel('Loss')&#10;    plt.xlabel('Epoch')&#10;    plt.legend(loc='upper right')&#10;&#10;    plt.tight_layout()&#10;    metrics_path = os.path.join(model_dir, 'training_metrics.png')&#10;    plt.savefig(metrics_path)&#10;    plt.close()&#10;    print(f&quot;Đã lưu biểu đồ Metrics tại: {metrics_path}&quot;)&#10;&#10;&#10;def train_and_save_model():&#10;    &quot;&quot;&quot;Huấn luyện và lưu model Deep Learning từ MySQL data.&quot;&quot;&quot;&#10;    global ai_model, scaler, encoder&#10;    print(&quot;Bắt đầu huấn luyện Model AI từ dữ liệu MySQL...&quot;)&#10;&#10;    # Lấy dữ liệu từ MySQL&#10;    customers_query = &quot;&quot;&quot;&#10;        SELECT c.customer_id, c.name, c.age, c.persona_type,&#10;               COALESCE(AVG(h.balance), 0) as avg_balance,&#10;               COALESCE(COUNT(DISTINCT v.flight_id), 0) as total_flights,&#10;               COALESCE(MAX(CASE WHEN v.ticket_class = 'business' THEN 1 ELSE 0 END), 0) as is_business_flyer,&#10;               COALESCE(SUM(r.nights_stayed), 0) as total_nights_stayed,&#10;               COALESCE(SUM(r.booking_value), 0) as total_resort_spending&#10;        FROM customers c&#10;        LEFT JOIN hdbank_transactions h ON c.customer_id = h.customer_id&#10;        LEFT JOIN vietjet_flights v ON c.customer_id = v.customer_id&#10;        LEFT JOIN resort_bookings r ON c.customer_id = r.customer_id&#10;        WHERE c.persona_type IS NOT NULL&#10;        GROUP BY c.customer_id, c.name, c.age, c.persona_type&#10;    &quot;&quot;&quot;&#10;&#10;    merged_df = pd.read_sql(customers_query, db.engine)&#10;&#10;    if merged_df.empty:&#10;        print(&quot;Không có dữ liệu để huấn luyện. Tạo dữ liệu mẫu...&quot;)&#10;        return create_mock_model()&#10;&#10;    # Feature Engineering&#10;    merged_df['is_business_flyer_int'] = merged_df['is_business_flyer'].astype(int)&#10;    merged_df.fillna(0, inplace=True)&#10;&#10;    X_raw = merged_df[feature_columns]&#10;    y_raw = merged_df[['persona_type']]&#10;&#10;    # Chuẩn hóa và mã hóa&#10;    scaler = StandardScaler()&#10;    X_scaled = scaler.fit_transform(X_raw)&#10;&#10;    encoder = OneHotEncoder(sparse_output=False)&#10;    y_encoded = encoder.fit_transform(y_raw)&#10;&#10;    # Xây dựng và huấn luyện model&#10;    model = tf.keras.Sequential([&#10;        tf.keras.layers.Input(shape=(X_scaled.shape[1],)),&#10;        tf.keras.layers.Dense(64, activation='relu'),&#10;        tf.keras.layers.Dense(32, activation='relu'),&#10;        tf.keras.layers.Dense(y_encoded.shape[1], activation='softmax')&#10;    ])&#10;    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])&#10;    history = model.fit(X_scaled, y_encoded, epochs=15, batch_size=64, verbose=1)&#10;&#10;    # Lưu trữ&#10;    if not os.path.exists(app.config['MODEL_DIR']):&#10;        os.makedirs(app.config['MODEL_DIR'])&#10;&#10;    model.save(os.path.join(app.config['MODEL_DIR'], 'persona_model.h5'))&#10;    joblib.dump(scaler, os.path.join(app.config['MODEL_DIR'], 'scaler.pkl'))&#10;    joblib.dump(encoder, os.path.join(app.config['MODEL_DIR'], 'encoder.pkl'))&#10;&#10;    plot_and_save_metrics(history, app.config['MODEL_DIR'])&#10;&#10;    ai_model, scaler, encoder = model, scaler, encoder&#10;    print(f&quot;Huấn luyện Model thành công!&quot;)&#10;&#10;&#10;def create_mock_model():&#10;    &quot;&quot;&quot;Tạo model mẫu nếu chưa có dữ liệu&quot;&quot;&quot;&#10;    global ai_model, scaler, encoder&#10;    print(&quot;Tạo Mock Model để demo...&quot;)&#10;&#10;    # Mock scaler và encoder&#10;    scaler = StandardScaler()&#10;    scaler.mean_ = np.array([35, 100000000, 10, 0.5, 3, 10000000])&#10;    scaler.scale_ = np.array([10, 50000000, 8, 0.5, 2, 5000000])&#10;&#10;    encoder = OneHotEncoder(sparse_output=False)&#10;    encoder.categories_ = [np.array(['doanh_nhan', 'gia_dinh', 'nguoi_tre'])]&#10;&#10;    # Mock model (sử dụng logic đơn giản)&#10;    class MockModel:&#10;        def predict(self, X):&#10;            # Logic đơn giản dựa trên features&#10;            results = []&#10;            for row in X:&#10;                age, balance, flights, is_biz, nights, resort_spending = row&#10;                if balance &gt; 200000000 or is_biz &gt; 0.5:&#10;                    results.append([0.8, 0.15, 0.05])  # doanh_nhan&#10;                elif age &lt; 30:&#10;                    results.append([0.1, 0.2, 0.7])  # nguoi_tre&#10;                else:&#10;                    results.append([0.2, 0.7, 0.1])  # gia_dinh&#10;            return np.array(results)&#10;&#10;    ai_model = MockModel()&#10;&#10;    # Lưu mock files&#10;    if not os.path.exists(app.config['MODEL_DIR']):&#10;        os.makedirs(app.config['MODEL_DIR'])&#10;    joblib.dump(scaler, os.path.join(app.config['MODEL_DIR'], 'scaler.pkl'))&#10;    joblib.dump(encoder, os.path.join(app.config['MODEL_DIR'], 'encoder.pkl'))&#10;&#10;&#10;def load_model():&#10;    &quot;&quot;&quot;Tải model đã được huấn luyện.&quot;&quot;&quot;&#10;    global ai_model, scaler, encoder&#10;    try:&#10;        ai_model = tf.keras.models.load_model(os.path.join(app.config['MODEL_DIR'], 'persona_model.h5'))&#10;        scaler = joblib.load(os.path.join(app.config['MODEL_DIR'], 'scaler.pkl'))&#10;        encoder = joblib.load(os.path.join(app.config['MODEL_DIR'], 'encoder.pkl'))&#10;        print(f&quot;Đã tải Model AI từ {app.config['MODEL_DIR']}&quot;)&#10;    except (IOError, OSError) as e:&#10;        print(f&quot;Lỗi khi tải model: {e}. Tạo model mới...&quot;)&#10;        train_and_save_model()&#10;&#10;&#10;def get_customer_360_profile(customer_id):&#10;    &quot;&quot;&quot;Lấy hồ sơ 360° từ MySQL.&quot;&quot;&quot;&#10;    customer = Customer.query.filter_by(customer_id=customer_id).first()&#10;    if not customer:&#10;        return None&#10;&#10;    # HDBank summary&#10;    hdbank_transactions = HDBankTransaction.query.filter_by(customer_id=customer_id).all()&#10;    hdbank_summary = {}&#10;    if hdbank_transactions:&#10;        balances = [float(t.balance) for t in hdbank_transactions]&#10;        amounts = [float(t.amount) for t in hdbank_transactions]&#10;        hdbank_summary = {&#10;            'total_transactions': len(hdbank_transactions),&#10;            'average_balance': sum(balances) / len(balances),&#10;            'total_credit_last_3m': sum(float(t.amount) for t in hdbank_transactions if t.transaction_type == 'credit'),&#10;            'total_debit_last_3m': sum(float(t.amount) for t in hdbank_transactions if t.transaction_type == 'debit')&#10;        }&#10;&#10;    # Vietjet summary&#10;    vietjet_flights = VietjetFlight.query.filter_by(customer_id=customer_id).all()&#10;    vietjet_summary = {}&#10;    if vietjet_flights:&#10;        vietjet_summary = {&#10;            'total_flights_last_year': len(vietjet_flights),&#10;            'total_spending': sum(float(f.booking_value) for f in vietjet_flights),&#10;            'is_business_flyer': any(f.ticket_class == 'business' for f in vietjet_flights),&#10;            'favorite_route': f&quot;{vietjet_flights[0].origin}-{vietjet_flights[0].destination}&quot; if vietjet_flights else &quot;N/A&quot;&#10;        }&#10;&#10;    # Resort summary&#10;    resort_bookings = ResortBooking.query.filter_by(customer_id=customer_id).all()&#10;    resort_summary = {}&#10;    if resort_bookings:&#10;        resort_summary = {&#10;            'total_bookings': len(resort_bookings),&#10;            'total_nights_stayed': sum(r.nights_stayed for r in resort_bookings),&#10;            'total_spending': sum(float(r.booking_value) for r in resort_bookings),&#10;            'favorite_resort': resort_bookings[0].resort_name if resort_bookings else &quot;N/A&quot;&#10;        }&#10;&#10;    return {&#10;        'basic_info': {&#10;            'customer_id': customer.customer_id,&#10;            'name': customer.name,&#10;            'age': customer.age,&#10;            'gender': customer.gender,&#10;            'job': customer.job,&#10;            'city': customer.city&#10;        },&#10;        'hdbank_summary': hdbank_summary,&#10;        'vietjet_summary': vietjet_summary,&#10;        'resort_summary': resort_summary&#10;    }&#10;&#10;&#10;@app.route('/api/nft/&lt;int:customer_id&gt;/achievements', methods=['GET'])&#10;def get_customer_achievements_api(customer_id):&#10;    &quot;&quot;&quot;API để lấy danh sách thành tựu của khách hàng cho NFT Passport&quot;&quot;&quot;&#10;    try:&#10;        # Query tất cả achievements của customer&#10;        customer_achievements = db.session.query(&#10;            CustomerAchievement, Achievement&#10;        ).join(Achievement).filter(&#10;            CustomerAchievement.customer_id == customer_id&#10;        ).all()&#10;&#10;        achievements = []&#10;        for ca, achievement in customer_achievements:&#10;            achievements.append({&#10;                'id': achievement.id,&#10;                'name': achievement.name,&#10;                'description': achievement.description,&#10;                'badge_image_url': achievement.badge_image_url,&#10;                'unlocked_at': ca.unlocked_at.isoformat() if ca.unlocked_at else None&#10;            })&#10;&#10;        return jsonify({&#10;            'customer_id': customer_id,&#10;            'achievements': achievements,&#10;            'total_achievements': len(achievements)&#10;        })&#10;&#10;    except Exception as e:&#10;        return jsonify({'error': f'Lỗi khi lấy thành tựu: {str(e)}'}), 500&#10;&#10;&#10;@app.route('/api/admin/assign-achievement', methods=['POST'])&#10;@require_auth&#10;def assign_achievement_to_customer():&#10;    &quot;&quot;&quot;API cho Admin/Chuyên viên để gán achievement cho khách hàng&quot;&quot;&quot;&#10;    try:&#10;        # Kiểm tra quyền admin&#10;        user = request.current_user&#10;        if user.role != 'admin':&#10;            return jsonify({'error': 'Chỉ admin mới có quyền gán thành tựu'}), 403&#10;&#10;        data = request.get_json()&#10;        customer_id = data.get('customer_id')&#10;        achievement_id = data.get('achievement_id')&#10;        admin_note = data.get('admin_note', '')&#10;&#10;        if not customer_id or not achievement_id:&#10;            return jsonify({'error': 'Thiếu customer_id hoặc achievement_id'}), 400&#10;&#10;        # Kiểm tra customer tồn tại&#10;        customer = Customer.query.filter_by(customer_id=customer_id).first()&#10;        if not customer:&#10;            return jsonify({'error': f'Khách hàng {customer_id} không tồn tại'}), 404&#10;&#10;        # Kiểm tra achievement tồn tại&#10;        achievement = Achievement.query.get(achievement_id)&#10;        if not achievement:&#10;            return jsonify({'error': f'Achievement {achievement_id} không tồn tại'}), 404&#10;&#10;        # Kiểm tra điều kiện đạt achievement&#10;        def check_eligibility(achievement, customer):&#10;            # Lấy số chuyến bay thực tế&#10;            flight_count = VietjetFlight.query.filter_by(customer_id=customer.customer_id).count()&#10;            # Lấy số dư trung bình thực tế&#10;            avg_balance = db.session.query(db.func.avg(HDBankTransaction.balance)).filter_by(&#10;                customer_id=customer.customer_id).scalar() or 0&#10;            # Lấy số đêm resort&#10;            resort_nights = db.session.query(db.func.sum(ResortBooking.nights_stayed)).filter_by(&#10;                customer_id=customer.customer_id).scalar() or 0&#10;&#10;            if 'Phi công Đồng' in achievement.name:&#10;                return flight_count &gt;= 5&#10;            elif 'Phi công Bạc' in achievement.name:&#10;                return flight_count &gt;= 10&#10;            elif 'Phi công Vàng' in achievement.name:&#10;                return flight_count &gt;= 20&#10;            elif 'Khách hàng VIP' in achievement.name:&#10;                return avg_balance &gt;= 200000000&#10;            elif 'Nhà đầu tư thông minh' in achievement.name:&#10;                return avg_balance &gt;= 500000000&#10;            elif 'Người du lịch' in achievement.name:&#10;                return resort_nights &gt;= 10&#10;            elif 'Người tiên phong' in achievement.name:&#10;                return False  # SVT balance chưa implement&#10;            return True  # Cho các achievement khác&#10;&#10;        if not check_eligibility(achievement, customer):&#10;            # Lấy thông tin hiện tại để hiển thị trong lỗi&#10;            flight_count = VietjetFlight.query.filter_by(customer_id=customer.customer_id).count()&#10;            avg_balance = db.session.query(db.func.avg(HDBankTransaction.balance)).filter_by(&#10;                customer_id=customer.customer_id).scalar() or 0&#10;            return jsonify({&#10;                'error': f'Khách hàng chưa đủ điều kiện cho &quot;{achievement.name}&quot;. Hiện tại: {flight_count} chuyến bay, {avg_balance:,.0f} VND'&#10;            }), 400&#10;&#10;        # Kiểm tra đã có achievement này chưa&#10;        existing = CustomerAchievement.query.filter_by(&#10;            customer_id=customer_id,&#10;            achievement_id=achievement_id&#10;        ).first()&#10;&#10;        if existing:&#10;            return jsonify({&#10;                'error': f'Khách hàng đã có achievement &quot;{achievement.name}&quot; rồi'&#10;            }), 400&#10;&#10;        # Gán achievement cho customer&#10;        customer_achievement = CustomerAchievement(&#10;            customer_id=customer_id,&#10;            achievement_id=achievement_id,&#10;            unlocked_at=datetime.datetime.utcnow()&#10;        )&#10;        db.session.add(customer_achievement)&#10;&#10;        # Thêm SVT token reward&#10;        svt_reward = 1000  # Default reward&#10;        if 'Phi công Vàng' in achievement.name:&#10;            svt_reward = 2000&#10;        elif 'Phi công Bạc' in achievement.name:&#10;            svt_reward = 1500&#10;        elif 'VIP' in achievement.name:&#10;            svt_reward = 1500&#10;&#10;        # Tạo token transaction&#10;        token_tx = TokenTransaction(&#10;            customer_id=customer_id,&#10;            transaction_type=&quot;achievement_reward&quot;,&#10;            amount=svt_reward,&#10;            description=f&quot;Admin gán thành tựu: {achievement.name}&quot;,&#10;            tx_hash=f&quot;0x{uuid.uuid4().hex}&quot;,&#10;            block_number=random.randint(1000000, 2000000)&#10;        )&#10;        db.session.add(token_tx)&#10;&#10;        db.session.commit()&#10;&#10;        return jsonify({&#10;            'success': True,&#10;            'message': f'Đã gán thành tựu &quot;{achievement.name}&quot; cho {customer.name}',&#10;            'customer_id': customer_id,&#10;            'customer_name': customer.name,&#10;            'achievement': {&#10;                'id': achievement.id,&#10;                'name': achievement.name,&#10;                'description': achievement.description,&#10;                'badge_image_url': achievement.badge_image_url&#10;            },&#10;            'svt_reward': svt_reward,&#10;            'assigned_by': user.email,&#10;            'assigned_at': customer_achievement.unlocked_at.isoformat()&#10;        })&#10;&#10;    except Exception as e:&#10;        db.session.rollback()&#10;        return jsonify({'error': f'Lỗi gán thành tựu: {str(e)}'}), 500&#10;&#10;&#10;@app.route('/api/admin/achievements', methods=['GET'])&#10;@require_auth&#10;def get_all_achievements():&#10;    &quot;&quot;&quot;API để lấy danh sách tất cả achievements có sẵn (cho admin)&quot;&quot;&quot;&#10;    try:&#10;        # Kiểm tra quyền admin&#10;        user = request.current_user&#10;        if user.role != 'admin':&#10;            return jsonify({'error': 'Chỉ admin mới có quyền xem danh sách achievements'}), 403&#10;&#10;        achievements = Achievement.query.all()&#10;&#10;        achievement_list = []&#10;        for achievement in achievements:&#10;            # Đếm số customer đã có achievement này&#10;            customer_count = CustomerAchievement.query.filter_by(&#10;                achievement_id=achievement.id&#10;            ).count()&#10;&#10;            achievement_list.append({&#10;                'id': achievement.id,&#10;                'name': achievement.name,&#10;                'description': achievement.description,&#10;                'badge_image_url': achievement.badge_image_url,&#10;                'customer_count': customer_count,&#10;                'created_at': achievement.created_at.isoformat() if achievement.created_at else None&#10;            })&#10;&#10;        return jsonify({&#10;            'success': True,&#10;            'achievements': achievement_list,&#10;            'total': len(achievement_list)&#10;        })&#10;&#10;    except Exception as e:&#10;        return jsonify({'error': f'Lỗi lấy danh sách achievements: {str(e)}'}), 500&#10;&#10;&#10;@app.route('/api/admin/create-achievement', methods=['POST'])&#10;@require_auth&#10;def create_new_achievement():&#10;    &quot;&quot;&quot;API cho Admin tạo achievement mới&quot;&quot;&quot;&#10;    try:&#10;        # Kiểm tra quyền admin&#10;        user = request.current_user&#10;        if user.role != 'admin':&#10;            return jsonify({'error': 'Chỉ admin mới có quyền tạo achievement'}), 403&#10;&#10;        data = request.get_json()&#10;        name = data.get('name')&#10;        description = data.get('description')&#10;        badge_image_url = data.get('badge_image_url', '/static/badges/default.png')&#10;&#10;        if not name or not description:&#10;            return jsonify({'error': 'Thiếu tên hoặc mô tả achievement'}), 400&#10;&#10;        # Kiểm tra tên đã tồn tại chưa&#10;        existing = Achievement.query.filter_by(name=name).first()&#10;        if existing:&#10;            return jsonify({'error': f'Achievement &quot;{name}&quot; đã tồn tại'}), 400&#10;&#10;        # Tạo achievement mới&#10;        new_achievement = Achievement(&#10;            name=name,&#10;            description=description,&#10;            badge_image_url=badge_image_url&#10;        )&#10;        db.session.add(new_achievement)&#10;        db.session.commit()&#10;&#10;        print(f&quot; Admin {user.email} tạo achievement mới: {name}&quot;)&#10;&#10;        return jsonify({&#10;            'success': True,&#10;            'message': f'Đã tạo achievement &quot;{name}&quot; thành công',&#10;            'achievement': {&#10;                'id': new_achievement.id,&#10;                'name': new_achievement.name,&#10;                'description': new_achievement.description,&#10;                'badge_image_url': new_achievement.badge_image_url,&#10;                'created_at': new_achievement.created_at.isoformat()&#10;            },&#10;            'created_by': user.email&#10;        })&#10;&#10;    except Exception as e:&#10;        db.session.rollback()&#10;        return jsonify({'error': f'Lỗi tạo achievement: {str(e)}'}), 500&#10;&#10;&#10;@app.route('/api/admin/customer/&lt;int:customer_id&gt;/achievements', methods=['GET'])&#10;@require_auth&#10;def get_customer_achievements_for_admin(customer_id):&#10;    &quot;&quot;&quot;API cho Admin xem tất cả achievements của khách hàng cụ thể&quot;&quot;&quot;&#10;    try:&#10;        # Kiểm tra quyền admin&#10;        user = request.current_user&#10;        if user.role != 'admin':&#10;            return jsonify({'error': 'Chỉ admin mới có quyền xem'}), 403&#10;&#10;        # Kiểm tra customer tồn tại&#10;        customer = Customer.query.filter_by(customer_id=customer_id).first()&#10;        if not customer:&#10;            return jsonify({'error': f'Khách hàng {customer_id} không tồn tại'}), 404&#10;&#10;        # Lấy tất cả achievements có sẵn&#10;        all_achievements = Achievement.query.all()&#10;&#10;        # Lấy achievements đã có của customer&#10;        customer_achievements = db.session.query(CustomerAchievement).filter_by(&#10;            customer_id=customer_id&#10;        ).all()&#10;&#10;        achieved_ids = {ca.achievement_id for ca in customer_achievements}&#10;&#10;        # Phân loại achievements&#10;        achieved_list = []&#10;        available_list = []&#10;&#10;        for achievement in all_achievements:&#10;            achievement_data = {&#10;                'id': achievement.id,&#10;                'name': achievement.name,&#10;                'description': achievement.description,&#10;                'badge_image_url': achievement.badge_image_url&#10;            }&#10;&#10;            if achievement.id in achieved_ids:&#10;                # Tìm thông tin unlock&#10;                ca = next(ca for ca in customer_achievements if ca.achievement_id == achievement.id)&#10;                achievement_data['unlocked_at'] = ca.unlocked_at.isoformat() if ca.unlocked_at else None&#10;                achieved_list.append(achievement_data)&#10;            else:&#10;                available_list.append(achievement_data)&#10;&#10;        # Thống kê hoạt động của customer&#10;        total_flights = VietjetFlight.query.filter_by(customer_id=customer_id).count()&#10;        total_resort_nights = db.session.query(db.func.sum(ResortBooking.nights_stayed)).filter_by(&#10;            customer_id=customer_id).scalar() or 0&#10;        avg_balance = db.session.query(db.func.avg(HDBankTransaction.balance)).filter_by(&#10;            customer_id=customer_id).scalar() or 0&#10;&#10;        return jsonify({&#10;            'success': True,&#10;            'customer': {&#10;                'customer_id': customer_id,&#10;                'name': customer.name,&#10;                'age': customer.age,&#10;                'city': customer.city,&#10;                'persona_type': customer.persona_type&#10;            },&#10;            'achievements': {&#10;                'achieved': achieved_list,&#10;                'available_to_assign': available_list,&#10;                'total_achieved': len(achieved_list),&#10;                'total_available': len(available_list)&#10;            },&#10;            'customer_stats': {&#10;                'total_flights': total_flights,&#10;                'total_resort_nights': int(total_resort_nights),&#10;                'avg_balance': float(avg_balance),&#10;                'member_since': customer.created_at.strftime('%Y-%m-%d') if customer.created_at else None&#10;            },&#10;            'suggested_achievements': get_suggested_achievements_for_customer(customer_id, total_flights,&#10;                                                                              total_resort_nights, avg_balance)&#10;        })&#10;&#10;    except Exception as e:&#10;        return jsonify({'error': f'Lỗi lấy thông tin: {str(e)}'}), 500&#10;&#10;&#10;def get_suggested_achievements_for_customer(customer_id, total_flights, total_resort_nights, avg_balance):&#10;    &quot;&quot;&quot;Gợi ý achievements phù hợp cho khách hàng dựa trên hoạt động&quot;&quot;&quot;&#10;    suggestions = []&#10;&#10;    # Kiểm tra các achievements đã có&#10;    existing_achievements = db.session.query(CustomerAchievement.achievement_id).filter_by(&#10;        customer_id=customer_id&#10;    ).all()&#10;    existing_ids = {ea.achievement_id for ea in existing_achievements}&#10;&#10;    # Logic gợi ý dựa trên hoạt động&#10;    if total_flights &gt;= 20:&#10;        # Gợi ý Phi công Vàng nếu chưa có&#10;        gold_pilot = Achievement.query.filter_by(name='Phi công Vàng').first()&#10;        if gold_pilot and gold_pilot.id not in existing_ids:&#10;            suggestions.append({&#10;                'achievement_id': gold_pilot.id,&#10;                'achievement_name': gold_pilot.name,&#10;                'reason': f'Khách hàng đã bay {total_flights} chuyến (≥20 chuyến)',&#10;                'confidence': 'high'&#10;            })&#10;    elif total_flights &gt;= 10:&#10;        # Gợi ý Phi công Bạc&#10;        silver_pilot = Achievement.query.filter_by(name='Phi công Bạc').first()&#10;        if silver_pilot and silver_pilot.id not in existing_ids:&#10;            suggestions.append({&#10;                'achievement_id': silver_pilot.id,&#10;                'achievement_name': silver_pilot.name,&#10;                'reason': f'Khách hàng đã bay {total_flights} chuyến (≥10 chuyến)',&#10;                'confidence': 'high'&#10;            })&#10;    elif total_flights &gt;= 5:&#10;        # Gợi ý Phi công Đồng&#10;        bronze_pilot = Achievement.query.filter_by(name='Phi công Đồng').first()&#10;        if bronze_pilot and bronze_pilot.id not in existing_ids:&#10;            suggestions.append({&#10;                'achievement_id': bronze_pilot.id,&#10;                'achievement_name': bronze_pilot.name,&#10;                'reason': f'Khách hàng đã bay {total_flights} chuyến (≥5 chuyến)',&#10;                'confidence': 'high'&#10;            })&#10;&#10;    # Gợi ý dựa trên số dư&#10;    if avg_balance &gt;= 100000000:  # ≥ 100 triệu&#10;        vip_achievement = Achievement.query.filter_by(name='Khách hàng VIP').first()&#10;        if vip_achievement and vip_achievement.id not in existing_ids:&#10;            suggestions.append({&#10;                'achievement_id': vip_achievement.id,&#10;                'achievement_name': vip_achievement.name,&#10;                'reason': f'Số dư trung bình {avg_balance:,.0f} VNĐ (≥100 triệu)',&#10;                'confidence': 'high'&#10;            })&#10;&#10;    # Gợi ý dựa trên nghỉ dưỡng&#10;    if total_resort_nights &gt;= 10:&#10;        traveler_achievement = Achievement.query.filter_by(name='Người du lịch').first()&#10;        if traveler_achievement and traveler_achievement.id not in existing_ids:&#10;            suggestions.append({&#10;                'achievement_id': traveler_achievement.id,&#10;                'achievement_name': traveler_achievement.name,&#10;                'reason': f'Đã nghỉ dưỡng {total_resort_nights} đêm (≥10 đêm)',&#10;                'confidence': 'medium'&#10;            })&#10;&#10;    return suggestions[:5]  # Giới hạn 5 gợi ý&#10;&#10;&#10;@app.route('/api/admin/bulk-assign-achievements', methods=['POST'])&#10;@require_auth&#10;def bulk_assign_achievements():&#10;    &quot;&quot;&quot;API gán achievements hàng loạt cho nhiều khách hàng&quot;&quot;&quot;&#10;    try:&#10;        # Kiểm tra quyền admin&#10;        user = request.current_user&#10;        if user.role != 'admin':&#10;            return jsonify({'error': 'Chỉ admin mới có quyền gán hàng loạt'}), 403&#10;&#10;        data = request.get_json()&#10;        customer_ids = data.get('customer_ids', [])&#10;        achievement_id = data.get('achievement_id')&#10;        admin_note = data.get('admin_note', 'Bulk assignment')&#10;&#10;        if not customer_ids or not achievement_id:&#10;            return jsonify({'error': 'Thiếu customer_ids hoặc achievement_id'}), 400&#10;&#10;        # Kiểm tra achievement tồn tại&#10;        achievement = Achievement.query.get(achievement_id)&#10;        if not achievement:&#10;            return jsonify({'error': f'Achievement {achievement_id} không tồn tại'}), 404&#10;&#10;        success_count = 0&#10;        errors = []&#10;&#10;        for customer_id in customer_ids:&#10;            try:&#10;                # Kiểm tra customer tồn tại&#10;                customer = Customer.query.filter_by(customer_id=customer_id).first()&#10;                if not customer:&#10;                    errors.append(f'Customer {customer_id}: không tồn tại')&#10;                    continue&#10;&#10;                # Kiểm tra đã có achievement chưa&#10;                existing = CustomerAchievement.query.filter_by(&#10;                    customer_id=customer_id,&#10;                    achievement_id=achievement_id&#10;                ).first()&#10;&#10;                if existing:&#10;                    errors.append(f'Customer {customer_id}: đã có achievement này')&#10;                    continue&#10;&#10;                # Gán achievement&#10;                customer_achievement = CustomerAchievement(&#10;                    customer_id=customer_id,&#10;                    achievement_id=achievement_id,&#10;                    unlocked_at=datetime.datetime.utcnow()&#10;                )&#10;                db.session.add(customer_achievement)&#10;&#10;                # Thêm SVT reward&#10;                svt_reward = 500  # Default reward for bulk assignment&#10;                token_tx = TokenTransaction(&#10;                    customer_id=customer_id,&#10;                    transaction_type=&quot;achievement_reward&quot;,&#10;                    amount=svt_reward,&#10;                    description=f&quot;Bulk assignment: {achievement.name}&quot;,&#10;                    tx_hash=f&quot;0x{uuid.uuid4().hex}&quot;,&#10;                    block_number=random.randint(1000000, 2000000)&#10;                )&#10;                db.session.add(token_tx)&#10;&#10;                success_count += 1&#10;&#10;            except Exception as e:&#10;                errors.append(f'Customer {customer_id}: {str(e)}')&#10;&#10;        db.session.commit()&#10;&#10;        print(f&quot; Admin {user.email} bulk assigned '{achievement.name}' to {success_count} customers&quot;)&#10;&#10;        return jsonify({&#10;            'success': True,&#10;            'message': f'Đã gán &quot;{achievement.name}&quot; cho {success_count} khách hàng',&#10;            'achievement_name': achievement.name,&#10;            'success_count': success_count,&#10;            'total_requested': len(customer_ids),&#10;            'errors': errors,&#10;            'assigned_by': user.email&#10;        })&#10;&#10;    except Exception as e:&#10;        db.session.rollback()&#10;        return jsonify({'error': f'Lỗi gán hàng loạt: {str(e)}'}), 500&#10;&#10;&#10;@app.route('/api/admin/auto-assign-achievements/&lt;int:customer_id&gt;', methods=['POST'])&#10;@require_auth&#10;def auto_assign_achievements(customer_id):&#10;    &quot;&quot;&quot;API tự động phân tích và gán achievements cho khách hàng dựa trên dữ liệu thực tế&quot;&quot;&quot;&#10;    try:&#10;        # Kiểm tra quyền admin&#10;        user = request.current_user&#10;        if user.role != 'admin':&#10;            return jsonify({'error': 'Chỉ admin mới có quyền tự động gán achievements'}), 403&#10;&#10;        # Kiểm tra customer tồn tại&#10;        customer = Customer.query.filter_by(customer_id=customer_id).first()&#10;        if not customer:&#10;            return jsonify({'error': f'Khách hàng {customer_id} không tồn tại'}), 404&#10;&#10;        # Thu thập dữ liệu thực tế của khách hàng&#10;        total_flights = VietjetFlight.query.filter_by(customer_id=customer_id).count()&#10;        avg_balance = db.session.query(db.func.avg(HDBankTransaction.balance)).filter_by(&#10;            customer_id=customer_id).scalar() or 0&#10;        total_resort_nights = db.session.query(db.func.sum(ResortBooking.nights_stayed)).filter_by(&#10;            customer_id=customer_id).scalar() or 0&#10;&#10;        # Lấy achievements đã có&#10;        existing_achievements = db.session.query(CustomerAchievement.achievement_id).filter_by(&#10;            customer_id=customer_id&#10;        ).all()&#10;        existing_ids = {ea.achievement_id for ea in existing_achievements}&#10;&#10;        # Logic tự động gán achievements&#10;        assigned_achievements = []&#10;        total_svt_reward = 0&#10;&#10;        # 1. Achievements bay&#10;        if total_flights &gt;= 20:&#10;            gold_pilot = Achievement.query.filter_by(name='Phi công Vàng').first()&#10;            if gold_pilot and gold_pilot.id not in existing_ids:&#10;                # Gán achievement&#10;                ca = CustomerAchievement(&#10;                    customer_id=customer_id,&#10;                    achievement_id=gold_pilot.id,&#10;                    unlocked_at=datetime.datetime.utcnow()&#10;                )&#10;                db.session.add(ca)&#10;&#10;                # Thêm SVT reward&#10;                token_tx = TokenTransaction(&#10;                    customer_id=customer_id,&#10;                    transaction_type=&quot;auto_achievement_reward&quot;,&#10;                    amount=2000,&#10;                    description=f&quot;Tự động gán: {gold_pilot.name}&quot;,&#10;                    tx_hash=f&quot;0x{uuid.uuid4().hex}&quot;,&#10;                    block_number=random.randint(1000000, 2000000)&#10;                )&#10;                db.session.add(token_tx)&#10;&#10;                assigned_achievements.append(gold_pilot.name)&#10;                total_svt_reward += 2000&#10;&#10;        elif total_flights &gt;= 10:&#10;            silver_pilot = Achievement.query.filter_by(name='Phi công Bạc').first()&#10;            if silver_pilot and silver_pilot.id not in existing_ids:&#10;                # Gán achievement&#10;                ca = CustomerAchievement(&#10;                    customer_id=customer_id,&#10;                    achievement_id=silver_pilot.id,&#10;                    unlocked_at=datetime.datetime.utcnow()&#10;                )&#10;                db.session.add(ca)&#10;&#10;                # Thêm SVT reward&#10;                token_tx = TokenTransaction(&#10;                    customer_id=customer_id,&#10;                    transaction_type=&quot;auto_achievement_reward&quot;,&#10;                    amount=1500,&#10;                    description=f&quot;Tự động gán: {silver_pilot.name}&quot;,&#10;                    tx_hash=f&quot;0x{uuid.uuid4().hex}&quot;,&#10;                    block_number=random.randint(1000000, 2000000)&#10;                )&#10;                db.session.add(token_tx)&#10;&#10;                assigned_achievements.append(silver_pilot.name)&#10;                total_svt_reward += 1500&#10;&#10;        elif total_flights &gt;= 5:&#10;            bronze_pilot = Achievement.query.filter_by(name='Phi công Đồng').first()&#10;            if bronze_pilot and bronze_pilot.id not in existing_ids:&#10;                # Gán achievement&#10;                ca = CustomerAchievement(&#10;                    customer_id=customer_id,&#10;                    achievement_id=bronze_pilot.id,&#10;                    unlocked_at=datetime.datetime.utcnow()&#10;                )&#10;                db.session.add(ca)&#10;&#10;                # Thêm SVT reward&#10;                token_tx = TokenTransaction(&#10;                    customer_id=customer_id,&#10;                    transaction_type=&quot;auto_achievement_reward&quot;,&#10;                    amount=1000,&#10;                    description=f&quot;Tự động gán: {bronze_pilot.name}&quot;,&#10;                    tx_hash=f&quot;0x{uuid.uuid4().hex}&quot;,&#10;                    block_number=random.randint(1000000, 2000000)&#10;                )&#10;                db.session.add(token_tx)&#10;&#10;                assigned_achievements.append(bronze_pilot.name)&#10;                total_svt_reward += 1000&#10;&#10;        # 2. VIP achievement&#10;        if avg_balance &gt;= 100000000:  # ≥ 100 triệu&#10;            vip_achievement = Achievement.query.filter_by(name='Khách hàng VIP').first()&#10;            if vip_achievement and vip_achievement.id not in existing_ids:&#10;                # Gán achievement&#10;                ca = CustomerAchievement(&#10;                    customer_id=customer_id,&#10;                    achievement_id=vip_achievement.id,&#10;                    unlocked_at=datetime.datetime.utcnow()&#10;                )&#10;                db.session.add(ca)&#10;&#10;                # Thêm SVT reward&#10;                token_tx = TokenTransaction(&#10;                    customer_id=customer_id,&#10;                    transaction_type=&quot;auto_achievement_reward&quot;,&#10;                    amount=1500,&#10;                    description=f&quot;Tự động gán: {vip_achievement.name}&quot;,&#10;                    tx_hash=f&quot;0x{uuid.uuid4().hex}&quot;,&#10;                    block_number=random.randint(1000000, 2000000)&#10;                )&#10;                db.session.add(token_tx)&#10;&#10;                assigned_achievements.append(vip_achievement.name)&#10;                total_svt_reward += 1500&#10;&#10;        # 3. Du lịch achievement&#10;        if total_resort_nights &gt;= 10:&#10;            traveler_achievement = Achievement.query.filter_by(name='Người du lịch').first()&#10;            if traveler_achievement and traveler_achievement.id not in existing_ids:&#10;                # Gán achievement&#10;                ca = CustomerAchievement(&#10;                    customer_id=customer_id,&#10;                    achievement_id=traveler_achievement.id,&#10;                    unlocked_at=datetime.datetime.utcnow()&#10;                )&#10;                db.session.add(ca)&#10;&#10;                # Thêm SVT reward&#10;                token_tx = TokenTransaction(&#10;                    customer_id=customer_id,&#10;                    transaction_type=&quot;auto_achievement_reward&quot;,&#10;                    amount=800,&#10;                    description=f&quot;Tự động gán: {traveler_achievement.name}&quot;,&#10;                    tx_hash=f&quot;0x{uuid.uuid4().hex}&quot;,&#10;                    block_number=random.randint(1000000, 2000000)&#10;                )&#10;                db.session.add(token_tx)&#10;&#10;                assigned_achievements.append(traveler_achievement.name)&#10;                total_svt_reward += 800&#10;&#10;        db.session.commit()&#10;&#10;        return jsonify({&#10;            'success': True,&#10;            'message': f'Đã tự động gán {len(assigned_achievements)} achievements cho {customer.name}',&#10;            'customer': {&#10;                'customer_id': customer_id,&#10;                'name': customer.name&#10;            },&#10;            'assigned_achievements': assigned_achievements,&#10;            'total_svt_reward': total_svt_reward,&#10;            'analysis_data': {&#10;                'total_flights': total_flights,&#10;                'avg_balance': float(avg_balance),&#10;                'total_resort_nights': int(total_resort_nights)&#10;            }&#10;        })&#10;&#10;    except Exception as e:&#10;        db.session.rollback()&#10;        return jsonify({'error': f'Lỗi tự động gán achievements: {str(e)}'}), 500&#10;&#10;&#10;@app.route('/admin/achievements', methods=['GET'])&#10;def get_all_achievements_simple():&#10;    &quot;&quot;&quot;API lấy tất cả achievements (không cần auth)&quot;&quot;&quot;&#10;    try:&#10;        achievements = Achievement.query.all()&#10;&#10;        achievement_list = []&#10;        for achievement in achievements:&#10;            # Đếm số customer đã có achievement này&#10;            customer_count = CustomerAchievement.query.filter_by(&#10;                achievement_id=achievement.id&#10;            ).count()&#10;&#10;            achievement_list.append({&#10;                'id': achievement.id,&#10;                'name': achievement.name,&#10;                'description': achievement.description,&#10;                'badge_image_url': achievement.badge_image_url,&#10;                'customer_count': customer_count,&#10;                'created_at': achievement.created_at.isoformat() if achievement.created_at else None&#10;            })&#10;&#10;        return jsonify({&#10;            'success': True,&#10;            'achievements': achievement_list,&#10;            'total': len(achievement_list)&#10;        })&#10;&#10;    except Exception as e:&#10;        return jsonify({'error': f'Lỗi lấy danh sách achievements: {str(e)}'}), 500&#10;&#10;&#10;# =============================================================================&#10;# MAIN&#10;# =============================================================================&#10;if __name__ == '__main__':&#10;    print(&quot;Khởi động One-Sovico Platform...&quot;)&#10;    print(f&quot;Database: {Config.get_database_url()}&quot;)&#10;&#10;    # Initialize app context, database tables, and AI model&#10;    try:&#10;        with app.app_context():&#10;            db.create_all()&#10;            load_model()&#10;            print(&quot;Khởi tạo cơ sở dữ liệu và AI model hoàn tất&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Lỗi khởi tạo ứng dụng: {e}&quot;)&#10;&#10;    print(&quot;Server đang chạy tại: http://127.0.0.1:5000&quot;)&#10;    app.run(debug=True, port=5000)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>